<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Trees That Shrink - Vaibhav Sagar</title>
        <link href="data:," rel="icon">
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
        <link rel="alternate" type="application/atom+xml" title="RSS feed for vaibhavsagar.com" href="../../../../../atom.xml" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../../../../about/">About</a>
                <a href="../../../../../talks/">Talks</a>
                <a href="../../../../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Trees That Shrink</h1>

            <div class="info">
    Posted on 19 June 2018
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'haskell'." href="../../../../../blog/tags/haskell/" rel="tag">haskell</a>, <a title="All pages tagged 'programming'." href="../../../../../blog/tags/programming/" rel="tag">programming</a>
    
</div>

<p><em>This blog post is also available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/trees-that-shrink/TreesThatShrink.ipynb">IHaskell notebook</a>.</em></p>
<p>I read <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">this paper</a> a while ago and people seemed pretty excited about it, although I couldn’t see why. Fortunately, someone posed me an interesting problem recently and in the process of tackling it I think I understand now.</p>
<p>Suppose we have a simple algebraic data type representing the lambda calculus with <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>, which are a way of avoiding the messy problem of variable names:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">Expr</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">=</span><span> </span><span class="dt">Lit</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Var</span><span> </span><span class="dt">Int</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Abs</span><span> </span><span class="ot">(</span><span class="dt">Expr</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">App</span><span> </span><span class="ot">(</span><span class="dt">Expr</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">Expr</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="ot">(</span><span class="dt">Show</span><span class="ot">)</span></code></pre></div>
<p>So far so good! Now we want to have let bindings in this language, and we’ve decided that we want named variables as well while we’re at it because de Bruijn indices are not so much fun to work with. We dutifully define another data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">=</span><span> </span><span class="dt">Lit'</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Var'</span><span> </span><span class="dt">String</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Abs'</span><span> </span><span class="ot">(</span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">App'</span><span> </span><span class="ot">(</span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Let'</span><span> </span><span class="dt">String</span><span> </span><span class="ot">(</span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="ot">(</span><span class="dt">Show</span><span class="ot">)</span></code></pre></div>
<p>Let bindings can be easily desugared into lambda abstractions as follows:</p>
<pre><code>let &lt;n&gt; = &lt;x&gt; in &lt;y&gt; &lt;=&gt; (\n -&gt; y) x</code></pre>
<p>which will help us to write a simpler evaluator. However, we’d also like to make sure the desugaring has been implemented correctly, perhaps by converting to some intermediate state where both the name and the correct de Bruijn index coexist peacefully. We have a couple of options, none of which are great:</p>
<ol type="1">
<li>Define a third data type and then write an indexing pass that converts <code>Var String</code> to <code>Var (String, Int)</code> and then a desugaring pass that converts that to <code>Expr a</code>.</li>
<li>Work entirely within the bigger data type, forget about indexing, and throw errors whenever a <code>Let</code> is encountered after a desugaring pass.</li>
<li>Combine the desugaring and indexing passes into one, and forget about keeping track of the desugaring.</li>
</ol>
<p>Let’s implement the third:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span><span> </span><span class="kw">qualified</span><span> </span><span class="dt">Data.Map.Strict</span><span> </span><span class="kw">as</span><span> </span><span class="dt">Map</span><span>

</span><span class="kw">type</span><span> </span><span class="dt">Env</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Map.Map</span><span> </span><span class="dt">String</span><span> </span><span class="dt">Int</span><span>

</span><span class="va">desugarAndAnonymise</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Env</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Expr'</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Expr</span><span> </span><span class="va">a</span><span>
</span><span class="va">desugarAndAnonymise</span><span> </span><span class="va">env</span><span> </span><span class="va">expr</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">expr</span><span> </span><span class="kw">of</span><span>
    </span><span class="dt">Lit'</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Lit</span><span> </span><span class="va">a</span><span>
    </span><span class="dt">Var'</span><span> </span><span class="va">name</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Var</span><span> </span><span class="ot">(</span><span class="va">env</span><span> </span><span class="op">Map.!</span><span> </span><span class="va">name</span><span class="ot">)</span><span>
    </span><span class="dt">Abs'</span><span> </span><span class="va">expr'</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">env'</span><span>  </span><span class="ot">=</span><span> </span><span class="va">Map.map</span><span> </span><span class="va">succ</span><span> </span><span class="va">env</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Abs</span><span> </span><span class="ot">(</span><span class="va">desugarAndAnonymise</span><span> </span><span class="va">env'</span><span> </span><span class="va">expr'</span><span class="ot">)</span><span>
    </span><span class="dt">App'</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">App</span><span> </span><span class="ot">(</span><span class="va">desugarAndAnonymise</span><span> </span><span class="va">env</span><span> </span><span class="va">f</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="va">desugarAndAnonymise</span><span> </span><span class="va">env</span><span> </span><span class="va">x</span><span class="ot">)</span><span>
    </span><span class="dt">Let'</span><span> </span><span class="va">n</span><span> </span><span class="va">v</span><span> </span><span class="va">expr'</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">desugarAndAnonymise</span><span> </span><span class="va">env</span><span> </span><span class="ot">(</span><span class="dt">App'</span><span> </span><span class="ot">(</span><span class="dt">Abs'</span><span> </span><span class="va">expr'</span><span class="ot">)</span><span> </span><span class="va">v</span><span class="ot">)</span></code></pre></div>
<p>That wasn’t a lot of fun to write, I have no idea if I did the conversion from names to indices correctly, and there’s no easy way to check if I did.</p>
<p>These problems are (barely) manageable in this case, but what if we want to add more syntax sugar or share this data type with other libraries that have different use cases? We’d either have to write variations on a theme over and over again or say goodbye to type safety. It also becomes harder and harder to decompose our functions into smaller ones that only do one thing. There has to be a better way!</p>
<p>This is the subject of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">Trees that Grow</a> by Shayan Najd and Simon Peyton Jones. They noticed the need for this approach when looking at GHC’s abstract syntax tree type but the idiom is generally applicable.</p>
<p>The first insight is that defining different data types for each use case is the wrong approach. Conceptually all these data types are the same type, just with different annotations or decoration, and we should be able to define the base data type with enough extensibility to accommodate all the other use cases.</p>
<p>The second insight is that we can use some of GHC’s fancier features to ease the pain of working with this ridiculously extensible data type, such as type families and pattern synonyms.</p>
<p>The third insight is that this can be made to work with other language features, such as generalised abstract data types and existentials! We won’t use this here, but it’s great to know that it’s possible.</p>
<p>Let’s see how we can use it to solve our problem. The first thing to do is turn on some language extensions, as with anything moderately fun in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="pp">{-# LANGUAGE TypeFamilies      #-}</span><span>
</span><span class="pp">{-# LANGUAGE PatternSynonyms   #-}</span></code></pre></div>
<p>The next steps are:</p>
<ol type="1">
<li>Add a type parameter to the data type declaration.</li>
<li>Add a field to each constructor with a new data type that uses this parameter (and any others).</li>
<li>Add an extra constructor to enable extending this data type, also with a new data type as in step 2.</li>
<li>Define type families for each of the new data types you declared in steps 2 and 3.</li>
</ol>
<p>And we’re done! This is what that looks like for our example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">(</span><span class="dt">XLit</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">VarX</span><span> </span><span class="ot">(</span><span class="dt">XVar</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">AbsX</span><span> </span><span class="ot">(</span><span class="dt">XAbs</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">(</span><span class="dt">XApp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">ExpX</span><span> </span><span class="ot">(</span><span class="dt">XExp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>

</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XLit</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XVar</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XAbs</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XApp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XExp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span></code></pre></div>
<p>The next thing to do is to reconstruct our original data type with no extensions. To do this we’ll need to use the <a href="http://hackage.haskell.org/package/base/docs/Data-Void.html"><code>Data.Void</code></a> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span><span> </span><span class="dt">Data.Void</span><span>

</span><span class="va">void</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Void</span><span>
</span><span class="va">void</span><span> </span><span class="ot">=</span><span> </span><span class="va">error</span><span> </span><span class="st">&quot;Attempt to evaluate void&quot;</span></code></pre></div>
<p>Now we can define <code>ExpUD</code> (UD for “undecorated”) using <code>Int</code> for our <code>Var</code> like we originally wanted and <code>Void</code> for all other extension points. It might get frustrating to construct and work with these values by hand, so we can use pattern synonyms to ease this pain.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">UD</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Int</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitUD</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">_</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">LitUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="va">void</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarUD</span><span> </span><span class="va">i</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">i</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">VarUD</span><span> </span><span class="va">i</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">i</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AbsX</span><span> </span><span class="ot">_</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">void</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppUD</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">_</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AppUD</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="va">void</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span></code></pre></div>
<p>This is unfortunately a bit boilerplate-y, but now we can define that intermediate data type that uses named variables as well as de Bruijn indices! As a bonus, we can now have named parameters to lambdas, which would not have been possible with the approach we tried to use above.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">Ann</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dt">String</span><span class="ot">,</span><span> </span><span class="dt">Int</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">_</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="va">void</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">VarX</span><span> </span><span class="ot">(</span><span class="va">s</span><span class="ot">,</span><span class="va">i</span><span class="ot">)</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="ot">(</span><span class="va">s</span><span class="ot">,</span><span> </span><span class="va">i</span><span class="ot">)</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">_</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="va">void</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span></code></pre></div>
<p>Now for my favourite part, where we add let bindings! We achieve this by using a tuple to represent <code>let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;</code> as <code>(&lt;name&gt;, &lt;expr&gt;, &lt;expr&gt;)</code>, and we use named variables and parameters in this representation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">Let</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dt">String</span><span class="ot">,</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span class="ot">,</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span class="ot">)</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitLet</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">_</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">LitLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="va">void</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarLet</span><span> </span><span class="va">s</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">s</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">VarLet</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">s</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppLet</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">_</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">where</span><span> </span><span class="dt">AppLet</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="va">void</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LetLet</span><span> </span><span class="va">n</span><span> </span><span class="va">v</span><span> </span><span class="va">e</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">ExpX</span><span> </span><span class="ot">(</span><span class="va">n</span><span class="ot">,</span><span class="va">v</span><span class="ot">,</span><span class="va">e</span><span class="ot">)</span></code></pre></div>
<p>Now instead of writing a single giant pass, we can write smaller ones!</p>
<p>We can write a desugarer that preserves names and rewrites our let bindings as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">desugar</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Env</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="va">desugar</span><span> </span><span class="va">env</span><span> </span><span class="va">expr</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">expr</span><span> </span><span class="kw">of</span><span>
    </span><span class="dt">LitLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="va">a</span><span>
    </span><span class="dt">VarLet</span><span> </span><span class="va">name</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="va">name</span><span> </span><span class="ot">(</span><span class="va">env</span><span> </span><span class="op">Map.!</span><span> </span><span class="va">name</span><span class="ot">)</span><span>
    </span><span class="dt">AbsLet</span><span> </span><span class="va">name</span><span> </span><span class="va">expr'</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">env'</span><span>  </span><span class="ot">=</span><span> </span><span class="va">Map.map</span><span> </span><span class="va">succ</span><span> </span><span class="va">env</span><span>
        </span><span class="va">env''</span><span> </span><span class="ot">=</span><span> </span><span class="va">Map.insert</span><span> </span><span class="va">name</span><span> </span><span class="dv">0</span><span> </span><span class="va">env'</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="va">name</span><span> </span><span class="ot">(</span><span class="va">desugar</span><span> </span><span class="va">env''</span><span> </span><span class="va">expr'</span><span class="ot">)</span><span>
    </span><span class="dt">AppLet</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="ot">(</span><span class="va">desugar</span><span> </span><span class="va">env</span><span> </span><span class="va">f</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="va">desugar</span><span> </span><span class="va">env</span><span> </span><span class="va">x</span><span class="ot">)</span><span>
    </span><span class="dt">LetLet</span><span> </span><span class="va">n</span><span> </span><span class="va">v</span><span> </span><span class="va">expr'</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">desugar</span><span> </span><span class="va">env</span><span> </span><span class="ot">(</span><span class="dt">AppLet</span><span> </span><span class="ot">(</span><span class="dt">AbsLet</span><span> </span><span class="va">n</span><span> </span><span class="va">expr'</span><span class="ot">)</span><span> </span><span class="va">v</span><span class="ot">)</span></code></pre></div>
<p>We can also write an anonymiser that throws the names away:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">anonymise</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="va">anonymise</span><span> </span><span class="va">expr</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">expr</span><span> </span><span class="kw">of</span><span>
    </span><span class="dt">LitAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">LitUD</span><span> </span><span class="va">a</span><span>
    </span><span class="dt">VarAnn</span><span> </span><span class="ot">_</span><span> </span><span class="va">i</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">VarUD</span><span> </span><span class="va">i</span><span>
    </span><span class="dt">AbsAnn</span><span> </span><span class="ot">_</span><span> </span><span class="va">e</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="ot">(</span><span class="va">anonymise</span><span> </span><span class="va">e</span><span class="ot">)</span><span>
    </span><span class="dt">AppAnn</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">AppUD</span><span> </span><span class="ot">(</span><span class="va">anonymise</span><span> </span><span class="va">f</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="va">anonymise</span><span> </span><span class="va">x</span><span class="ot">)</span></code></pre></div>
<p>And finally an evaluator that operates on undecorated expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">eval</span><span> </span><span class="ot">::</span><span> </span><span class="ot">[</span><span class="va">a</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span>
</span><span class="va">eval</span><span> </span><span class="va">env</span><span> </span><span class="va">expr</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">expr</span><span> </span><span class="kw">of</span><span>
    </span><span class="dt">LitUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span>
    </span><span class="dt">VarUD</span><span> </span><span class="va">i</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">env</span><span> </span><span class="op">!!</span><span> </span><span class="va">i</span><span>
    </span><span class="dt">AbsUD</span><span> </span><span class="va">f</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">eval</span><span> </span><span class="va">env</span><span> </span><span class="va">f</span><span>
    </span><span class="dt">AppUD</span><span> </span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">x'</span><span> </span><span class="ot">=</span><span> </span><span class="va">eval</span><span> </span><span class="va">env</span><span> </span><span class="va">x</span><span>
        </span><span class="kw">in</span><span> </span><span class="va">eval</span><span> </span><span class="ot">(</span><span class="va">env</span><span> </span><span class="op">++</span><span> </span><span class="ot">[</span><span class="va">x'</span><span class="ot">]</span><span class="ot">)</span><span> </span><span class="va">f</span></code></pre></div>
<p>Let’s see it in action!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">identity</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="st">&quot;i&quot;</span><span> </span><span class="ot">(</span><span class="dt">VarLet</span><span> </span><span class="st">&quot;i&quot;</span><span class="ot">)</span><span>
</span><span class="va">konst</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dt">AbsLet</span><span> </span><span class="st">&quot;x&quot;</span><span> </span><span class="ot">(</span><span class="dt">AbsLet</span><span> </span><span class="st">&quot;y&quot;</span><span> </span><span class="ot">(</span><span class="dt">VarLet</span><span> </span><span class="st">&quot;x&quot;</span><span class="ot">)</span><span class="ot">)</span><span class="ot">)</span><span>

</span><span class="va">eval</span><span> </span><span class="ot">[</span><span class="ot">]</span><span> </span><span class="op">.</span><span> </span><span class="va">anonymise</span><span> </span><span class="op">.</span><span> </span><span class="va">desugar</span><span> </span><span class="va">Map.empty</span><span> </span><span class="op">$</span><span> </span><span class="dt">AppLet</span><span> </span><span class="ot">(</span><span class="dt">AppLet</span><span> </span><span class="va">konst</span><span> </span><span class="ot">(</span><span class="dt">LitLet</span><span> </span><span class="dv">1</span><span class="ot">)</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">LitLet</span><span> </span><span class="dv">2</span><span class="ot">)</span></code></pre></div>
<pre><code>1</code></pre>
<p>Awesome! We have composable compiler passes that are easier to write and to think about. Even with this small example, I hope the benefits are clear.</p>
<p>Edit: <a href="https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/e0x8se2">Edward Kmett points out</a> that using <code>Void</code> makes this approach unnecessarily footgun-prone and suggests using strict fields and <code>()</code> instead. This allows for simpler pattern synonyms and comes with the additional benefit that we can disable constructors with <code>Void</code> so we can actually have trees that shrink:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">!</span><span class="ot">(</span><span class="dt">XLit</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">VarX</span><span> </span><span class="ot">!</span><span class="ot">(</span><span class="dt">XVar</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">AbsX</span><span> </span><span class="ot">!</span><span class="ot">(</span><span class="dt">XAbs</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">!</span><span class="ot">(</span><span class="dt">XApp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="dt">ExpX</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">ExpX</span><span> </span><span class="ot">!</span><span class="ot">(</span><span class="dt">XExp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span class="ot">)</span><span>

</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XLit</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XVar</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XAbs</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XApp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">family</span><span> </span><span class="dt">XExp</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>

</span><span class="kw">type</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">UD</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Int</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">UD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitUD</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarUD</span><span> </span><span class="va">i</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">i</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppUD</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpUD</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppUD</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>

</span><span class="kw">type</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">Ann</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dt">String</span><span class="ot">,</span><span> </span><span class="dt">Int</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">Ann</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Void</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="ot">(</span><span class="va">s</span><span class="ot">,</span><span> </span><span class="va">i</span><span class="ot">)</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsAnn</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpAnn</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppAnn</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>

</span><span class="kw">type</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ExpX</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span>
</span><span class="kw">data</span><span> </span><span class="dt">Let</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XLit</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XVar</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XAbs</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">String</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XApp</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="kw">type</span><span> </span><span class="kw">instance</span><span> </span><span class="dt">XExp</span><span> </span><span class="dt">Let</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dt">String</span><span class="ot">,</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span class="ot">,</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span class="ot">)</span><span>

</span><span class="kw">pattern</span><span> </span><span class="dt">LitLet</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LitLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">LitX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">VarLet</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="dt">VarX</span><span> </span><span class="va">s</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AbsLet</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AbsX</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppLet</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ExpLet</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">AppLet</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">AppX</span><span> </span><span class="ot">(</span><span class="ot">)</span><span> </span><span class="va">f</span><span> </span><span class="va">a</span><span>
</span><span class="kw">pattern</span><span> </span><span class="dt">LetLet</span><span> </span><span class="va">n</span><span> </span><span class="va">v</span><span> </span><span class="va">e</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="dt">ExpX</span><span> </span><span class="ot">(</span><span class="va">n</span><span class="ot">,</span><span class="va">v</span><span class="ot">,</span><span class="va">e</span><span class="ot">)</span></code></pre></div>
<p>The definitions of <code>desugar</code>, <code>anonymise</code>, and <code>eval</code> are unchanged.</p>
<p>Thanks to <a href="http://andychu.net/">Andy Chu</a> and <a href="https://push.cx/">Peter Bhat Harkins</a> for comments and feedback.</p>

        </div>
        <div id="footer">
            <div class="rc-webring">
                <a href="https://webring.recurse.com"><img src="https://webring.recurse.com/icon.svg" /> RC Webring</a>
            </div>
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
        <script data-goatcounter="//vaibhavsagar.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <script type="text/javascript" id="MathJax-script" async src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
        </script>
        <script>
        window.MathJax = {
            loader: {load: ['[tex]/color', '[tex]/cancel', '[tex]/textmacros']},
            tex: {packages: {'[+]': ['color', 'cancel', 'textmacros']}}
        };
        </script>
    </body>
</html>
