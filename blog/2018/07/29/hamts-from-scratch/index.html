<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>HAMTs from Scratch - Vaibhav Sagar</title>
        <link href="data:," rel="icon">
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../../../../about/">About</a>
                <a href="../../../../../talks/">Talks</a>
                <a href="../../../../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>HAMTs from Scratch</h1>

            <div class="info">
    Posted on 29 July 2018
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'programming'." href="../../../../../blog/tags/programming/" rel="tag">programming</a>, <a title="All pages tagged 'haskell'." href="../../../../../blog/tags/haskell/" rel="tag">haskell</a>
    
</div>

<p><em>This blog post is also an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/hamt/HAMTsFromScratch.ipynb">IHaskell notebook</a> and the source is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/hamt/hamt">separately</a>. I also <a href="https://www.youtube.com/watch?v=wgMgtgVZdYg">did a talk at NYHUG based on this material</a>.</em></p>
<p>I wanted an explanation for HAMTs (Hash Array Mapped Tries) that was more detailed than <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt/">Marek Majkowski’s introduction</a> and more approachable than <a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf"><em>Ideal Hash Trees</em> by Phil Bagwell</a>, the paper that introduced them. If you haven’t heard of them before, HAMTs are a way of efficiently representing a hashtable as a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>, and although they were first envisioned as a mutable data structure they are easily adapted to work as a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>. They form the backbone of the <a href="http://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a> library but the <a href="https://github.com/tibbe/unordered-containers/blob/efa43a2ab09dc6eb72893d12676a8e188cb4ca63/Data/HashMap/Base.hs">implementation has been lovingly optimised</a> to the point where I found it impenetrable. <a href="https://github.com/ezyang/hamt/blob/a43559795630980eb16ab832a003d8e6acd21cf6/HAMT.hs">Edward Z. Yang’s implementation</a> is much easier to follow and after adapting it I think I’m in a good place to provide my own take on them.</p>
<p>Let’s start with a few imports! I’ll be using these packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base"><code>base</code></a></li>
<li><a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a></li>
<li><a href="http://hackage.haskell.org/package/memory"><code>memory</code></a></li>
<li><a href="http://hackage.haskell.org/package/pretty-show"><code>pretty-show</code></a></li>
<li><a href="http://hackage.haskell.org/package/timeit"><code>timeit</code></a></li>
<li><a href="http://hackage.haskell.org/package/vector"><code>vector</code></a></li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import</span><span> </span><span class="dt">Data.Bits</span><span>             </span><span class="ot">(</span><span class="dt">Bits</span><span> </span><span class="ot">(</span><span class="va">bit</span><span class="ot">,</span><span> </span><span class="va">complement</span><span class="ot">,</span><span> </span><span class="va">popCount</span><span class="ot">,</span><span> </span><span class="va">shiftR</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="op">.&amp;.</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="op">.|.</span><span class="ot">)</span><span class="ot">)</span><span class="ot">,</span><span>
                              </span><span class="dt">FiniteBits</span><span> </span><span class="ot">(</span><span class="va">finiteBitSize</span><span class="ot">)</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.ByteArray.Hash</span><span>   </span><span class="ot">(</span><span class="dt">FnvHash32</span><span> </span><span class="ot">(</span><span class="ot">..</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="va">fnv1Hash</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.ByteString.Char8</span><span> </span><span class="ot">(</span><span class="va">pack</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.Char</span><span>             </span><span class="ot">(</span><span class="va">intToDigit</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.Semigroup</span><span>        </span><span class="ot">(</span><span class="ot">(</span><span class="op">&lt;&gt;</span><span class="ot">)</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.Vector</span><span>           </span><span class="ot">(</span><span class="dt">Vector</span><span class="ot">,</span><span> </span><span class="va">drop</span><span class="ot">,</span><span> </span><span class="va">singleton</span><span class="ot">,</span><span> </span><span class="va">take</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="op">!</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="op">//</span><span class="ot">)</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Data.Word</span><span>             </span><span class="ot">(</span><span class="dt">Word16</span><span class="ot">,</span><span> </span><span class="dt">Word32</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Numeric</span><span>               </span><span class="ot">(</span><span class="va">showIntAtBase</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Prelude</span><span>               </span><span class="kw">hiding</span><span> </span><span class="ot">(</span><span class="va">drop</span><span class="ot">,</span><span> </span><span class="va">lookup</span><span class="ot">,</span><span> </span><span class="va">take</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">System.TimeIt</span><span>         </span><span class="ot">(</span><span class="va">timeIt</span><span class="ot">)</span><span>
</span><span class="kw">import</span><span> </span><span class="dt">Text.Show.Pretty</span><span>      </span><span class="ot">(</span><span class="va">pPrint</span><span class="ot">)</span></code></pre></div>
<p>We’re going to be doing some bit twiddling. To make this easier to follow I’m going to define a <code>newtype</code> whose <code>Show</code> instance displays the binary representation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="pp">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span><span>

</span><span class="kw">newtype</span><span> </span><span class="dt">Binary</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Binary</span><span> </span><span class="va">a</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="ot">(</span><span class="dt">Enum</span><span class="ot">,</span><span> </span><span class="dt">Ord</span><span class="ot">,</span><span> </span><span class="dt">Real</span><span class="ot">,</span><span> </span><span class="dt">Integral</span><span class="ot">,</span><span> </span><span class="dt">Eq</span><span class="ot">,</span><span> </span><span class="dt">Num</span><span class="ot">,</span><span> </span><span class="dt">Bits</span><span class="ot">,</span><span> </span><span class="dt">FiniteBits</span><span class="ot">)</span><span>

</span><span class="kw">instance</span><span> </span><span class="ot">(</span><span class="dt">FiniteBits</span><span> </span><span class="va">a</span><span class="ot">,</span><span> </span><span class="dt">Show</span><span> </span><span class="va">a</span><span class="ot">,</span><span> </span><span class="dt">Integral</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="dt">Show</span><span> </span><span class="ot">(</span><span class="dt">Binary</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">show</span><span> </span><span class="ot">(</span><span class="dt">Binary</span><span> </span><span class="va">n</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">str</span><span> </span><span class="ot">=</span><span> </span><span class="va">showIntAtBase</span><span> </span><span class="dv">2</span><span> </span><span class="va">intToDigit</span><span> </span><span class="va">n</span><span> </span><span class="st">&quot;&quot;</span><span>
        </span><span class="va">size</span><span> </span><span class="ot">=</span><span> </span><span class="va">finiteBitSize</span><span> </span><span class="va">n</span><span>
        </span><span class="kw">in</span><span> </span><span class="va">replicate</span><span> </span><span class="ot">(</span><span class="va">size</span><span> </span><span class="op">-</span><span> </span><span class="va">length</span><span> </span><span class="va">str</span><span class="ot">)</span><span> </span><span class="ch">'0'</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">str</span></code></pre></div>
<p>Using this <code>newtype</code> we can turn this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">24732</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Word16</span></code></pre></div>
<pre><code>24732</code></pre>
<p>into this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">24732</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Binary</span><span> </span><span class="dt">Word16</span></code></pre></div>
<pre><code>0110000010011100</code></pre>
<p>I’m going to use 32-bit hashes (because they’re more convenient to display than 64-bit ones) and 16-bit bitmaps.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Binary</span><span> </span><span class="dt">Word32</span><span>
</span><span class="kw">type</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Binary</span><span> </span><span class="dt">Word16</span></code></pre></div>
<p>The width of bitmaps is <span class="math inline">\(2^n\)</span> where <span class="math inline">\(n\)</span> is the number of bits of the hash that we use at each level of the tree (more on this below). I’m setting <span class="math inline">\(n=4\)</span> which is what <code>unordered-containers</code> uses (as of this writing), but we could e.g. set <span class="math inline">\(n=5\)</span> and use 32-bit bitmaps if we wanted.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">bitsPerSubkey</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">bitsPerSubkey</span><span> </span><span class="ot">=</span><span> </span><span class="dv">4</span></code></pre></div>
<p><code>Shift</code> is a multiple of <span class="math inline">\(n\)</span> that we will use to focus on the correct part of the hash.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Int</span></code></pre></div>
<p>I’m also going to define a <code>Hashable</code> class to decouple the choice of a hash function from the implementation of <code>HAMT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span><span> </span><span class="dt">Hashable</span><span> </span><span class="va">a</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">hash</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Hash</span></code></pre></div>
<p>For convenience, we’ll use the FNV-1 hash function with strings.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="pp">{-# LANGUAGE TypeSynonymInstances #-}</span><span>
</span><span class="pp">{-# LANGUAGE FlexibleInstances #-}</span><span>

</span><span class="kw">instance</span><span> </span><span class="dt">Hashable</span><span> </span><span class="dt">String</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">hash</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="dt">FnvHash32</span><span> </span><span class="va">h</span><span> </span><span class="ot">=</span><span> </span><span class="va">fnv1Hash</span><span> </span><span class="ot">(</span><span class="va">pack</span><span> </span><span class="va">s</span><span class="ot">)</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Binary</span><span> </span><span class="va">h</span></code></pre></div>
<p>Here’s what it looks like in practice.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">hash</span><span> </span><span class="st">&quot;1&quot;</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Binary</span><span> </span><span class="dt">Word32</span></code></pre></div>
<pre><code>00000101000011000101110100101110</code></pre>
<p>A HAMT can be</p>
<ul>
<li>empty (<code>None</code>)</li>
<li>a leaf node with the hash, the key, and the value (<code>Leaf</code>)</li>
<li>a node with a bitmap and a (non-empty) vector of child HAMTs (<code>Many</code>)</li>
</ul>
<p>I’ve chosen to ignore the possibility of collisions, but we could handle them by adding an extra constructor, e.g. <code>Colliding</code> with a hash and a vector of key-value pairs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
    </span><span class="ot">=</span><span> </span><span class="dt">None</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Leaf</span><span> </span><span class="dt">Hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
    </span><span class="ot">|</span><span> </span><span class="dt">Many</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">(</span><span class="dt">Vector</span><span> </span><span class="ot">(</span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span class="ot">)</span><span class="ot">)</span><span>
    </span><span class="kw">deriving</span><span> </span><span class="ot">(</span><span class="dt">Show</span><span class="ot">)</span><span>

</span><span class="va">empty</span><span> </span><span class="ot">::</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">k</span><span> </span><span class="va">v</span><span>
</span><span class="va">empty</span><span> </span><span class="ot">=</span><span> </span><span class="dt">None</span></code></pre></div>
<p>We’ll need some helper functions for vectors:</p>
<ul>
<li><code>insertAt</code> inserts an element at a specified index, shifting elements to the right forwards</li>
<li><code>updateAt</code> replaces an element at a specified index with a new element</li>
<li><code>deleteAt</code> removes an element at an index, shifting elements to the right backwards</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insertAt</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span>
</span><span class="va">insertAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="va">take</span><span> </span><span class="va">index</span><span> </span><span class="va">vector</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">singleton</span><span> </span><span class="va">a</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">drop</span><span> </span><span class="va">index</span><span> </span><span class="va">vector</span><span>

</span><span class="va">updateAt</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span>
</span><span class="va">updateAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="va">vector</span><span> </span><span class="op">//</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="va">index</span><span class="ot">,</span><span> </span><span class="va">a</span><span class="ot">)</span><span class="ot">]</span><span>

</span><span class="va">deleteAt</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Vector</span><span> </span><span class="va">a</span><span>
</span><span class="va">deleteAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">take</span><span> </span><span class="va">index</span><span> </span><span class="va">vector</span><span> </span><span class="op">&lt;&gt;</span><span> </span><span class="va">drop</span><span> </span><span class="ot">(</span><span class="va">index</span><span class="op">+</span><span class="dv">1</span><span class="ot">)</span><span> </span><span class="va">vector</span></code></pre></div>
<h3 id="insert">Insert</h3>
<p>I think the bit manipulation functions are crucial to understanding what’s going on, so I’m going to motivate them by trying to define <code>insert</code> without them and coming up with them as they are needed. This initial definition won’t be quite right so I’ll call it <code>insert_</code> to differentiate it from the correct <code>insert'</code> function I present later. The type signature for <code>insert_</code> is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">key</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span></code></pre></div>
<p>Inserting a key-value pair into an empty HAMT gives us a single leaf node:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="dt">None</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span></code></pre></div>
<p>Inserting a key-value pair into a single leaf node where the hashes match gives us an updated leaf node (because we’re pretending collisions don’t exist):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Leaf</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">leafKey</span><span> </span><span class="va">leafValue</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">hash</span><span> </span><span class="op">==</span><span> </span><span class="va">leafHash</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span></code></pre></div>
<p>Inserting into a HAMT consisting of a single leaf node where the hashes don’t match upgrades that leaf node to a <code>Many</code> node and inserts the key-value pair into that <code>Many</code> node:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="va">leaf</span><span class="ot">@</span><span class="ot">(</span><span class="dt">Leaf</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">leafKey</span><span> </span><span class="va">leafValue</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">hash</span><span> </span><span class="op">/=</span><span> </span><span class="va">leafHash</span><span> </span><span class="ot">=</span><span> </span><span class="va">insert_</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">someBitmap</span><span> </span><span class="ot">(</span><span class="va">singleton</span><span> </span><span class="va">leaf</span><span class="ot">)</span><span class="ot">)</span><span>
    </span><span class="kw">where</span><span> </span><span class="va">someBitmap</span><span> </span><span class="ot">=</span><span> </span><span class="va">undefined</span></code></pre></div>
<h4 id="bit-masking">Bit Masking</h4>
<p>Where does <code>someBitmap</code> come from? Time for an example! Let’s start with a <code>Leaf (hash "1") "1" 1</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">h</span><span> </span><span class="ot">=</span><span> </span><span class="va">hash</span><span> </span><span class="st">&quot;1&quot;</span><span>
</span><span class="va">leaf</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">h</span><span> </span><span class="st">&quot;1&quot;</span><span> </span><span class="dv">1</span><span>

</span><span class="va">leaf</span></code></pre></div>
<pre><code>Leaf 00000101000011000101110100101110 &quot;1&quot; 1</code></pre>
<p><code>someBitMap</code> is a 16-bit bitmap where the number of bits set (the <code>popCount</code>) is the length of the vector, which in this case is <span class="math inline">\(1\)</span>. We want to set one bit, but which bit? We carve off the last <span class="math inline">\(n\)</span> bits using a mask:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">subkeyMask</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Bitmap</span><span>
</span><span class="va">subkeyMask</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="va">bit</span><span> </span><span class="va">bitsPerSubkey</span><span class="ot">)</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span><span>

</span><span class="va">subkeyMask</span></code></pre></div>
<pre><code>0000000000001111</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--     0101110100101110</span><span>
</span><span class="co">-- .&amp;. 0000000000001111</span><span>
</span><span class="co">-----------------------</span><span>
</span><span class="co">--     0000000000001110</span><span>

</span><span class="va">fragment</span><span> </span><span class="ot">=</span><span> </span><span class="va">fromIntegral</span><span> </span><span class="va">h</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">subkeyMask</span><span>

</span><span class="va">fragment</span></code></pre></div>
<pre><code>0000000000001110</code></pre>
<p>Then we interpret that fragment as a number:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Binary</span><span> </span><span class="va">position</span><span> </span><span class="ot">=</span><span> </span><span class="va">fragment</span><span>

</span><span class="va">position</span></code></pre></div>
<pre><code>14</code></pre>
<p>Finally, we set that bit and we have our bitmap:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">someBitmap</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Bitmap</span><span>
</span><span class="va">someBitmap</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Binary</span><span> </span><span class="op">$</span><span> </span><span class="va">bit</span><span> </span><span class="op">$</span><span> </span><span class="va">fromIntegral</span><span> </span><span class="va">position</span><span>

</span><span class="va">someBitmap</span></code></pre></div>
<pre><code>0100000000000000</code></pre>
<p>We’re going to be doing this a lot, so I’ll define this as <code>bitMask_</code>. The extra <code>_</code> is because it isn’t quite right for the same reason as <code>insert_</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">bitMask_</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bitmap</span><span>
</span><span class="va">bitMask_</span><span> </span><span class="va">hash</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
    </span><span class="va">fragment</span><span> </span><span class="ot">=</span><span> </span><span class="va">fromIntegral</span><span> </span><span class="va">hash</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">subkeyMask</span><span>
    </span><span class="dt">Binary</span><span> </span><span class="va">position</span><span> </span><span class="ot">=</span><span> </span><span class="va">fragment</span><span>
    </span><span class="kw">in</span><span> </span><span class="dt">Binary</span><span> </span><span class="ot">(</span><span class="va">bit</span><span> </span><span class="ot">(</span><span class="va">fromIntegral</span><span> </span><span class="va">position</span><span class="ot">)</span><span class="ot">)</span></code></pre></div>
<p>Let’s look at the <code>Many</code> case. If we try inserting into a node where the bit in the bitmap corresponding to the mask is <code>0</code>, this means that there is an empty slot in the vector. We can insert a leaf node into this slot and set the corresponding bit in the bitmap to <code>1</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">mask</span><span> </span><span class="op">==</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">leaf</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="ot">(</span><span class="va">hash</span><span> </span><span class="va">key</span><span class="ot">)</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
        </span><span class="va">vector'</span><span> </span><span class="ot">=</span><span> </span><span class="va">insertAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">leaf</span><span>
        </span><span class="va">bitmap'</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.|.</span><span> </span><span class="va">mask</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Many</span><span> </span><span class="va">bitmap'</span><span> </span><span class="va">vector'</span><span>
    </span><span class="kw">where</span><span>
        </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask_</span><span> </span><span class="va">hash</span><span>
        </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">undefined</span></code></pre></div>
<h4 id="mask-indexing">Mask Indexing</h4>
<p>What <code>index</code> do we use? This is where <code>popCount</code> makes an appearance. Let’s demonstrate by inserting <code>("10", 2)</code> into our example. First we get the mask corresponding to <code>hash "10"</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask_</span><span> </span><span class="ot">(</span><span class="va">hash</span><span> </span><span class="st">&quot;10&quot;</span><span class="ot">)</span><span>

</span><span class="va">mask</span></code></pre></div>
<pre><code>0000010000000000</code></pre>
<p>Next we want to find the number of lower bits that have been set. We use <code>mask - 1</code> as a mask:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">mask</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span></code></pre></div>
<pre><code>0000001111111111</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--     0100000000000000</span><span>
</span><span class="co">-- .&amp;. 0000001111111111</span><span>
</span><span class="co">-----------------------</span><span>
</span><span class="co">--     0000000000000000</span><span>

</span><span class="va">masked</span><span> </span><span class="ot">=</span><span> </span><span class="va">someBitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="ot">(</span><span class="va">mask</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span><span class="ot">)</span><span>

</span><span class="va">masked</span></code></pre></div>
<pre><code>0000000000000000</code></pre>
<p>Then we count the number of bits set with <code>popCount</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">popCount</span><span> </span><span class="va">masked</span><span>

</span><span class="va">index</span></code></pre></div>
<pre><code>0</code></pre>
<p>And this is the index we need to insert at! We’ll call this <code>maskIndex</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">maskIndex</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">popCount</span><span> </span><span class="ot">(</span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="ot">(</span><span class="va">mask</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span><span class="ot">)</span><span class="ot">)</span></code></pre></div>
<p>The final case is where the bit in the bitmap is already set. We need to recursively update the HAMT at the corresponding index:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">mask</span><span> </span><span class="op">==</span><span> </span><span class="dv">1</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">subtree'</span><span> </span><span class="ot">=</span><span> </span><span class="va">insert_</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="va">vector</span><span> </span><span class="op">!</span><span> </span><span class="va">index</span><span class="ot">)</span><span> </span><span class="co">-- WRONG!</span><span>
        </span><span class="va">vector'</span><span> </span><span class="ot">=</span><span> </span><span class="va">updateAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">subtree'</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector'</span><span>
    </span><span class="kw">where</span><span>
        </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask_</span><span> </span><span class="va">hash</span><span>
        </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span></code></pre></div>
<p>But this definition is wrong, because instead of carving off the last <span class="math inline">\(n\)</span> bits of <code>hash</code>, we want to recursively carve off the next <span class="math inline">\(n\)</span> bits!</p>
<h4 id="shifting">Shifting</h4>
<p>This is what’s missing from our definition, a <code>shift</code> parameter corresponding to how far up the <code>hash</code> we’re looking. This is why we defined <code>Shift</code> above. Taking this extra parameter into account, our bit manipulation functions now become:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">subkeyMask</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Bitmap</span><span>
</span><span class="va">subkeyMask</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="va">bit</span><span> </span><span class="va">bitsPerSubkey</span><span class="ot">)</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span><span>

</span><span class="va">maskIndex</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bitmap</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">popCount</span><span> </span><span class="ot">(</span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="ot">(</span><span class="va">mask</span><span> </span><span class="op">-</span><span> </span><span class="dv">1</span><span class="ot">)</span><span class="ot">)</span><span>

</span><span class="va">subkey</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">subkey</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span> </span><span class="ot">=</span><span> </span><span class="va">fromIntegral</span><span> </span><span class="op">$</span><span> </span><span class="ot">(</span><span class="va">fromIntegral</span><span> </span><span class="op">$</span><span> </span><span class="va">shiftR</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span class="ot">)</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">subkeyMask</span><span>

</span><span class="va">bitMask</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bitmap</span><span>
</span><span class="va">bitMask</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span> </span><span class="ot">=</span><span> </span><span class="va">bit</span><span> </span><span class="ot">(</span><span class="va">subkey</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span class="ot">)</span></code></pre></div>
<p>We plumb through this <code>shift</code> parameter, only modifying it in the final case, to give us the correct definitions of <code>insert'</code> and <code>insert</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">insert</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hashable</span><span> </span><span class="va">key</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="va">key</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
</span><span class="va">insert</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="va">hamt</span><span> </span><span class="ot">=</span><span> </span><span class="va">insert'</span><span> </span><span class="dv">0</span><span> </span><span class="ot">(</span><span class="va">hash</span><span> </span><span class="va">key</span><span class="ot">)</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="va">hamt</span><span>

</span><span class="va">insert'</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">key</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
</span><span class="va">insert'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="dt">None</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>

</span><span class="va">insert'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="va">leaf</span><span class="ot">@</span><span class="ot">(</span><span class="dt">Leaf</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">leafKey</span><span> </span><span class="va">leafValue</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">hash</span><span> </span><span class="op">==</span><span> </span><span class="va">leafHash</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="va">insert'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="ot">(</span><span class="va">bitMask</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">shift</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="va">singleton</span><span> </span><span class="va">leaf</span><span class="ot">)</span><span class="ot">)</span><span>

</span><span class="va">insert'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">mask</span><span> </span><span class="op">==</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">leaf</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Leaf</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
        </span><span class="va">vector'</span><span> </span><span class="ot">=</span><span> </span><span class="va">insertAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">leaf</span><span>
        </span><span class="va">bitmap'</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.|.</span><span> </span><span class="va">mask</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Many</span><span> </span><span class="va">bitmap'</span><span> </span><span class="va">vector'</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">subtree</span><span> </span><span class="ot">=</span><span> </span><span class="va">vector</span><span> </span><span class="op">!</span><span> </span><span class="va">index</span><span>
        </span><span class="va">subtree'</span><span> </span><span class="ot">=</span><span> </span><span class="va">insert'</span><span> </span><span class="ot">(</span><span class="va">shift</span><span class="op">+</span><span class="va">bitsPerSubkey</span><span class="ot">)</span><span> </span><span class="va">hash</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="va">subtree</span><span>
        </span><span class="va">vector'</span><span> </span><span class="ot">=</span><span> </span><span class="va">updateAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">subtree'</span><span>
        </span><span class="kw">in</span><span> </span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector'</span><span>
    </span><span class="kw">where</span><span>
        </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span>
        </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span></code></pre></div>
<p>Now we can construct HAMTs and inspect them! I’ll define a <code>fromList</code> function and use <code>pPrint</code> from <code>pretty-show</code> to highlight the tree structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">fromList</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hashable</span><span> </span><span class="va">key</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="va">key</span><span class="ot">,</span><span> </span><span class="va">value</span><span class="ot">)</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
</span><span class="va">fromList</span><span> </span><span class="ot">=</span><span> </span><span class="va">foldr</span><span> </span><span class="ot">(</span><span class="va">uncurry</span><span> </span><span class="va">insert</span><span class="ot">)</span><span> </span><span class="va">empty</span><span>

</span><span class="va">example</span><span> </span><span class="ot">=</span><span> </span><span class="va">fromList</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="st">&quot;1&quot;</span><span class="ot">,</span><span> </span><span class="dv">1</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="st">&quot;10&quot;</span><span class="ot">,</span><span> </span><span class="dv">2</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="st">&quot;100&quot;</span><span class="ot">,</span><span> </span><span class="dv">3</span><span class="ot">)</span><span class="ot">,</span><span> </span><span class="ot">(</span><span class="st">&quot;1000&quot;</span><span class="ot">,</span><span> </span><span class="dv">4</span><span class="ot">)</span><span class="ot">]</span><span>

</span><span class="va">pPrint</span><span> </span><span class="va">example</span></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000100100000
      [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2
      , Leaf 10001010111100101011011010001010 &quot;1000&quot; 4
      ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<h3 id="lookup">Lookup</h3>
<p>Compared to <code>insert</code>, <code>lookup</code> is a walk in the park. It’s implemented along the same lines as <code>insert</code>:</p>
<ul>
<li>on <code>None</code> nodes, it fails</li>
<li>on <code>Leaf</code> nodes, it succeeds if the hashes match</li>
<li>on <code>Many</code> nodes, it fails if the bit isn’t set, and recurses into the child node otherwise</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">lookup</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hashable</span><span> </span><span class="va">key</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="va">key</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Maybe</span><span> </span><span class="va">value</span><span>
</span><span class="va">lookup</span><span> </span><span class="va">key</span><span> </span><span class="va">hamt</span><span> </span><span class="ot">=</span><span> </span><span class="va">lookup'</span><span> </span><span class="dv">0</span><span> </span><span class="ot">(</span><span class="va">hash</span><span> </span><span class="va">key</span><span class="ot">)</span><span> </span><span class="va">hamt</span><span>

</span><span class="va">lookup'</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Maybe</span><span> </span><span class="va">value</span><span>
</span><span class="va">lookup'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="dt">None</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Nothing</span><span>

</span><span class="va">lookup'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="ot">(</span><span class="dt">Leaf</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">leafKey</span><span> </span><span class="va">leafValue</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">hash</span><span> </span><span class="op">==</span><span> </span><span class="va">leafHash</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Just</span><span> </span><span class="va">leafValue</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Nothing</span><span>

</span><span class="va">lookup'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">mask</span><span> </span><span class="op">==</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Nothing</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="va">lookup'</span><span> </span><span class="ot">(</span><span class="va">shift</span><span class="op">+</span><span class="va">bitsPerSubkey</span><span class="ot">)</span><span> </span><span class="va">hash</span><span> </span><span class="ot">(</span><span class="va">vector</span><span> </span><span class="op">!</span><span> </span><span class="va">index</span><span class="ot">)</span><span>
    </span><span class="kw">where</span><span>
        </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span>
        </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span></code></pre></div>
<p>Let’s quickly confirm that it works.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">lookup</span><span> </span><span class="st">&quot;100&quot;</span><span> </span><span class="va">example</span></code></pre></div>
<pre><code>Just 3</code></pre>
<h4 id="memoising-fibonacci">Memoising Fibonacci</h4>
<p>We now have enough of an API to use this as a hashtable! Let’s use it to memoise the calculation of the Fibonacci sequence. The naive implementation does a lot of unnecessary recomputation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">fib</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">fib</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="dv">1</span><span>
</span><span class="va">fib</span><span> </span><span class="dv">1</span><span> </span><span class="ot">=</span><span> </span><span class="dv">1</span><span>
</span><span class="va">fib</span><span> </span><span class="va">n</span><span> </span><span class="ot">=</span><span> </span><span class="va">fib</span><span> </span><span class="ot">(</span><span class="va">n</span><span class="op">-</span><span class="dv">1</span><span class="ot">)</span><span> </span><span class="op">+</span><span> </span><span class="va">fib</span><span> </span><span class="ot">(</span><span class="va">n</span><span class="op">-</span><span class="dv">2</span><span class="ot">)</span><span>

</span><span class="va">timeIt</span><span> </span><span class="op">$</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">fib</span><span> </span><span class="dv">30</span></code></pre></div>
<pre><code>1346269
CPU time:   1.31s</code></pre>
<p>We can memoise it by storing previously calculated results and using them if they are available:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span><span> </span><span class="dt">Hashable</span><span> </span><span class="dt">Int</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">hash</span><span> </span><span class="va">int</span><span> </span><span class="ot">=</span><span> </span><span class="dt">Binary</span><span> </span><span class="ot">(</span><span class="va">fromIntegral</span><span> </span><span class="va">int</span><span class="ot">)</span><span>

</span><span class="va">fib'</span><span> </span><span class="ot">::</span><span> </span><span class="dt">HAMT</span><span> </span><span class="dt">Int</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="dt">Int</span><span class="ot">,</span><span> </span><span class="dt">HAMT</span><span> </span><span class="dt">Int</span><span> </span><span class="dt">Int</span><span class="ot">)</span><span>
</span><span class="va">fib'</span><span> </span><span class="va">table</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dv">1</span><span class="ot">,</span><span> </span><span class="va">insert</span><span> </span><span class="dv">0</span><span> </span><span class="dv">1</span><span> </span><span class="va">table</span><span class="ot">)</span><span>
</span><span class="va">fib'</span><span> </span><span class="va">table</span><span> </span><span class="dv">1</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="dv">1</span><span class="ot">,</span><span> </span><span class="va">insert</span><span> </span><span class="dv">1</span><span> </span><span class="dv">1</span><span> </span><span class="va">table</span><span class="ot">)</span><span>
</span><span class="va">fib'</span><span> </span><span class="va">table</span><span> </span><span class="va">n</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">lookup</span><span> </span><span class="va">n</span><span> </span><span class="va">table</span><span> </span><span class="kw">of</span><span>
    </span><span class="dt">Just</span><span> </span><span class="va">i</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">table</span><span class="ot">)</span><span>
    </span><span class="dt">Nothing</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">let</span><span>
        </span><span class="ot">(</span><span class="va">i1</span><span class="ot">,</span><span> </span><span class="va">table'</span><span class="ot">)</span><span>  </span><span class="ot">=</span><span> </span><span class="va">fib'</span><span> </span><span class="va">table</span><span>  </span><span class="ot">(</span><span class="va">n</span><span class="op">-</span><span class="dv">1</span><span class="ot">)</span><span>
        </span><span class="ot">(</span><span class="va">i2</span><span class="ot">,</span><span> </span><span class="va">table''</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">fib'</span><span> </span><span class="va">table'</span><span> </span><span class="ot">(</span><span class="va">n</span><span class="op">-</span><span class="dv">2</span><span class="ot">)</span><span>
        </span><span class="kw">in</span><span> </span><span class="ot">(</span><span class="va">i1</span><span> </span><span class="op">+</span><span> </span><span class="va">i2</span><span class="ot">,</span><span> </span><span class="va">insert</span><span> </span><span class="va">n</span><span> </span><span class="ot">(</span><span class="va">i1</span><span> </span><span class="op">+</span><span> </span><span class="va">i2</span><span class="ot">)</span><span> </span><span class="va">table''</span><span class="ot">)</span><span>

</span><span class="va">fib</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Int</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">fib</span><span> </span><span class="va">n</span><span> </span><span class="ot">=</span><span> </span><span class="va">fst</span><span> </span><span class="op">$</span><span> </span><span class="va">fib'</span><span> </span><span class="va">empty</span><span> </span><span class="va">n</span><span>

</span><span class="va">timeIt</span><span> </span><span class="op">$</span><span> </span><span class="va">print</span><span> </span><span class="op">$</span><span> </span><span class="va">fib</span><span> </span><span class="dv">30</span></code></pre></div>
<pre><code>1346269
CPU time:   0.00s</code></pre>
<h3 id="delete">Delete</h3>
<p>Finally we come to <code>delete</code>, which is only a little more complex than <code>lookup</code>. It needs to make sure that no <code>Many</code> node has a child <code>None</code> node, so if a <code>None</code> node:</p>
<ul>
<li>is an only child, it will replace the parent node</li>
<li>has any sibling nodes, it will be removed from the parent node’s bitmap and vector</li>
</ul>
<p><code>Leaf</code> nodes similarly replace their parents if they are the only child.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">delete</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Hashable</span><span> </span><span class="va">key</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="va">key</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
</span><span class="va">delete</span><span> </span><span class="va">key</span><span> </span><span class="va">hamt</span><span> </span><span class="ot">=</span><span> </span><span class="va">delete'</span><span> </span><span class="dv">0</span><span> </span><span class="ot">(</span><span class="va">hash</span><span> </span><span class="va">key</span><span class="ot">)</span><span> </span><span class="va">hamt</span><span>

</span><span class="va">delete'</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Shift</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Hash</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">HAMT</span><span> </span><span class="va">key</span><span> </span><span class="va">value</span><span>
</span><span class="va">delete'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="dt">None</span><span> </span><span class="ot">=</span><span> </span><span class="dt">None</span><span>

</span><span class="va">delete'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">leaf</span><span class="ot">@</span><span class="ot">(</span><span class="dt">Leaf</span><span> </span><span class="va">leafHash</span><span> </span><span class="va">leafKey</span><span> </span><span class="va">leafValue</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">hash</span><span> </span><span class="op">==</span><span> </span><span class="va">leafHash</span><span> </span><span class="ot">=</span><span> </span><span class="dt">None</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="va">leaf</span><span>

</span><span class="va">delete'</span><span> </span><span class="va">shift</span><span> </span><span class="va">hash</span><span> </span><span class="va">many</span><span class="ot">@</span><span class="ot">(</span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">vector</span><span class="ot">)</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">mask</span><span> </span><span class="op">==</span><span> </span><span class="dv">0</span><span> </span><span class="ot">=</span><span> </span><span class="va">many</span><span>
    </span><span class="ot">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="ot">=</span><span> </span><span class="kw">let</span><span>
        </span><span class="va">subtree</span><span> </span><span class="ot">=</span><span> </span><span class="va">vector</span><span> </span><span class="op">!</span><span> </span><span class="va">index</span><span>
        </span><span class="va">subtree'</span><span> </span><span class="ot">=</span><span> </span><span class="va">delete'</span><span> </span><span class="ot">(</span><span class="va">shift</span><span class="op">+</span><span class="va">bitsPerSubkey</span><span class="ot">)</span><span> </span><span class="va">hash</span><span> </span><span class="va">subtree</span><span>
        </span><span class="kw">in</span><span> </span><span class="kw">case</span><span> </span><span class="va">subtree'</span><span> </span><span class="kw">of</span><span>
            </span><span class="dt">None</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">if</span><span> </span><span class="va">length</span><span> </span><span class="va">vector</span><span> </span><span class="op">==</span><span> </span><span class="dv">1</span><span>
                </span><span class="kw">then</span><span> </span><span class="dt">None</span><span>
                </span><span class="kw">else</span><span> </span><span class="dt">Many</span><span> </span><span class="ot">(</span><span class="va">bitmap</span><span> </span><span class="op">.&amp;.</span><span> </span><span class="va">complement</span><span> </span><span class="va">mask</span><span class="ot">)</span><span> </span><span class="ot">(</span><span class="va">deleteAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span class="ot">)</span><span>
            </span><span class="dt">Leaf</span><span class="ot">{</span><span class="ot">}</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">if</span><span> </span><span class="va">length</span><span> </span><span class="va">vector</span><span> </span><span class="op">==</span><span> </span><span class="dv">1</span><span>
                </span><span class="kw">then</span><span> </span><span class="va">subtree'</span><span>
                </span><span class="kw">else</span><span>  </span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="ot">(</span><span class="va">updateAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">subtree'</span><span class="ot">)</span><span>
            </span><span class="dt">Many</span><span class="ot">{</span><span class="ot">}</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Many</span><span> </span><span class="va">bitmap</span><span> </span><span class="ot">(</span><span class="va">updateAt</span><span> </span><span class="va">vector</span><span> </span><span class="va">index</span><span> </span><span class="va">subtree'</span><span class="ot">)</span><span>
    </span><span class="kw">where</span><span>
        </span><span class="va">mask</span><span> </span><span class="ot">=</span><span> </span><span class="va">bitMask</span><span> </span><span class="va">hash</span><span> </span><span class="va">shift</span><span>
        </span><span class="va">index</span><span> </span><span class="ot">=</span><span> </span><span class="va">maskIndex</span><span> </span><span class="va">bitmap</span><span> </span><span class="va">mask</span></code></pre></div>
<p>Let’s see this in action.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">pPrint</span><span> </span><span class="op">$</span><span> </span><span class="va">delete</span><span> </span><span class="st">&quot;1000&quot;</span><span> </span><span class="va">example</span></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000000100000 [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2 ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>It’s possible to have a situation where we have a <code>Many</code> node with only one child, because our replacement behaviour checks the length of the vector before any elements are removed from it. However, removing the last leaf will correctly delete the parent node.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">pPrint</span><span> </span><span class="op">$</span><span> </span><span class="va">delete</span><span> </span><span class="st">&quot;10&quot;</span><span> </span><span class="op">$</span><span> </span><span class="va">delete</span><span> </span><span class="st">&quot;1000&quot;</span><span> </span><span class="va">example</span></code></pre></div>
<pre><code>Many
  0100000000000000
  [ Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>And we’re done! I hope you understand HAMTs better than when you started reading this.</p>
<p>If you want to use this for something other than educational purposes, I would recommend adding logic to deal with hash collisions, which I intentionally omitted. There’s also some low-hanging fruit in terms of performance optimisations. The first thing that comes to mind is an additional <code>Full</code> constructor for the case where all bits in the bitmap are set, and the next thing is the use of unsafe vector functions that omit bounds checking.</p>
<p>Thanks to <a href="https://twitter.com/evanborden">Evan Borden</a>, <a href="https://twitter.com/candeira">Javier Candeira</a>, <a href="https://hypirion.com/">Jean Niklas L’orange</a>, <a href="http://mjhopkins.github.io/">Mark Hopkins</a>, and <a href="https://teh.id.au/">Tim Humphries</a> for comments and feedback.</p>

        </div>
        <div id="footer">
            <div class="rc-webring">
                <a href="https://webring.recurse.com"><img src="https://webring.recurse.com/icon.svg" /> RC Webring</a>
            </div>
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
        <script data-goatcounter="//vaibhavsagar.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <script type="text/javascript" id="MathJax-script" async src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
        </script>
        <script>
        window.MathJax = {
            loader: {load: ['[tex]/color', '[tex]/cancel', '[tex]/textmacros']},
            tex: {packages: {'[+]': ['color', 'cancel', 'textmacros']}}
        };
        </script>
    </body>
</html>
