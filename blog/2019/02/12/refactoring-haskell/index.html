<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Refactoring Haskell: A Case Study - Vaibhav Sagar</title>
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../../../../about/">About</a>
                <a href="../../../../../talks/">Talks</a>
                <a href="../../../../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Refactoring Haskell: A Case Study</h1>

            <div class="info">
    Posted on 12 February 2019
    
</div>
<div class="info">
    
        Tags: <a href="../../../../../blog/tags/programming/">programming</a>, <a href="../../../../../blog/tags/haskell/">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT problem</a> is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="../../../../../blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2-SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>This code isn’t particularly elegant or easy to follow, and it’s lousy with mutable state. Despite these drawbacks, it is still relatively straightforward to refactor.</p>
<p>If you’d like to follow along, I have the code (and some test data) available <a href="https://gist.github.com/vaibhavsagar/2418c9dd79da431065ad0d80e690b12f">at this gist</a> with each revision representing a refactoring step.</p>
<p>The initial version of the code is as follows:</p>
<details>
<p><summary style="cursor: pointer">Initial 2SAT.hs</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_, when)</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]</span>
<span id="cb1-17"><a href="#cb1-17"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb1-20"><a href="#cb1-20"></a>    stackSet <span class="ot">&lt;-</span> newSTRef S.empty</span>
<span id="cb1-21"><a href="#cb1-21"></a>    indices  <span class="ot">&lt;-</span> newSTRef M.empty</span>
<span id="cb1-22"><a href="#cb1-22"></a>    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty</span>
<span id="cb1-23"><a href="#cb1-23"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="op">&lt;$&gt;</span> readSTRef indices</span>
<span id="cb1-27"><a href="#cb1-27"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a>    readSTRef output</span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>strongConnect</span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)</span>
<span id="cb1-39"><a href="#cb1-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb1-40"><a href="#cb1-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])</span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb1-43"><a href="#cb1-43"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>    insert v i indices</span>
<span id="cb1-46"><a href="#cb1-46"></a>    insert v i lowlinks</span>
<span id="cb1-47"><a href="#cb1-47"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-48"><a href="#cb1-48"></a>    push stack stackSet v</span>
<span id="cb1-49"><a href="#cb1-49"></a></span>
<span id="cb1-50"><a href="#cb1-50"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">lookup</span> w indices <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb1-53"><a href="#cb1-53"></a>            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-54"><a href="#cb1-54"></a>            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> w lowlinks</span>
<span id="cb1-55"><a href="#cb1-55"></a>            insert v (<span class="fu">min</span> vLowLink wLowLink) lowlinks</span>
<span id="cb1-56"><a href="#cb1-56"></a>        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>            wOnStack <span class="ot">&lt;-</span> S.member w <span class="op">&lt;$&gt;</span> readSTRef stackSet</span>
<span id="cb1-58"><a href="#cb1-58"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-59"><a href="#cb1-59"></a>                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-60"><a href="#cb1-60"></a>                insert v (<span class="fu">min</span> vLowLink wIndex) lowlinks</span>
<span id="cb1-61"><a href="#cb1-61"></a></span>
<span id="cb1-62"><a href="#cb1-62"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-63"><a href="#cb1-63"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v indices</span>
<span id="cb1-64"><a href="#cb1-64"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet</span>
<span id="cb1-66"><a href="#cb1-66"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb1-67"><a href="#cb1-67"></a>    <span class="kw">where</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>        <span class="fu">lookup</span> value hashMap     <span class="ot">=</span> M.lookup value <span class="op">&lt;$&gt;</span> readSTRef hashMap</span>
<span id="cb1-69"><a href="#cb1-69"></a>        insert key value hashMap <span class="ot">=</span> modifySTRef' hashMap (M.insert key value)</span>
<span id="cb1-70"><a href="#cb1-70"></a></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))</span>
<span id="cb1-72"><a href="#cb1-72"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb1-73"><a href="#cb1-73"></a>    <span class="kw">let</span> scc' <span class="ot">=</span> S.insert w scc</span>
<span id="cb1-74"><a href="#cb1-74"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</span>
<span id="cb1-75"><a href="#cb1-75"></a></span>
<span id="cb1-76"><a href="#cb1-76"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb1-77"><a href="#cb1-77"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-78"><a href="#cb1-78"></a>    modifySTRef' stack    (e<span class="op">:</span>)</span>
<span id="cb1-79"><a href="#cb1-79"></a>    modifySTRef' stackSet (S.insert e)</span>
<span id="cb1-80"><a href="#cb1-80"></a></span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb1-82"><a href="#cb1-82"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-83"><a href="#cb1-83"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb1-84"><a href="#cb1-84"></a>    modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>    modifySTRef' stackSet (S.delete e)</span>
<span id="cb1-86"><a href="#cb1-86"></a>    <span class="fu">return</span> e</span>
<span id="cb1-87"><a href="#cb1-87"></a></span>
<span id="cb1-88"><a href="#cb1-88"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb1-89"><a href="#cb1-89"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb1-90"><a href="#cb1-90"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb1-91"><a href="#cb1-91"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb1-92"><a href="#cb1-92"></a></span>
<span id="cb1-93"><a href="#cb1-93"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb1-94"><a href="#cb1-94"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-95"><a href="#cb1-95"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb1-96"><a href="#cb1-96"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb1-97"><a href="#cb1-97"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb1-98"><a href="#cb1-98"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb1-99"><a href="#cb1-99"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations, such as checking if <code>w</code> is on the stack and looking up indices, happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations. A better choice would be <a href="http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html"><code>Data.Vector.Mutable</code></a> from the <code>vector</code> package, which does have constant-time operations.</p>
<p>This refactoring mostly consists of initialising vectors with a known length and replacing calls to <code>lookup</code> and <code>insert</code> with calls to <code>read</code> and <code>write</code>.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>vector</code></summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb2-16"><a href="#cb2-16"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb2-19"><a href="#cb2-19"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</span>
<span id="cb2-26"><a href="#cb2-26"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a>    readSTRef output</span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="kw">where</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-32"><a href="#cb2-32"></a></span>
<span id="cb2-33"><a href="#cb2-33"></a>strongConnect</span>
<span id="cb2-34"><a href="#cb2-34"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb2-39"><a href="#cb2-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb2-40"><a href="#cb2-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb2-41"><a href="#cb2-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb2-42"><a href="#cb2-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb2-43"><a href="#cb2-43"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb2-44"><a href="#cb2-44"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-45"><a href="#cb2-45"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb2-46"><a href="#cb2-46"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb2-47"><a href="#cb2-47"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb2-48"><a href="#cb2-48"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb2-49"><a href="#cb2-49"></a>    push stack stackSet v</span>
<span id="cb2-50"><a href="#cb2-50"></a></span>
<span id="cb2-51"><a href="#cb2-51"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb2-52"><a href="#cb2-52"></a>        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-53"><a href="#cb2-53"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb2-54"><a href="#cb2-54"></a>            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-55"><a href="#cb2-55"></a>            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks w</span>
<span id="cb2-56"><a href="#cb2-56"></a>            write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wLowLink))</span>
<span id="cb2-57"><a href="#cb2-57"></a>        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</span>
<span id="cb2-59"><a href="#cb2-59"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-60"><a href="#cb2-60"></a>                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-61"><a href="#cb2-61"></a>                write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wIndex))</span>
<span id="cb2-62"><a href="#cb2-62"></a></span>
<span id="cb2-63"><a href="#cb2-63"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-64"><a href="#cb2-64"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</span>
<span id="cb2-65"><a href="#cb2-65"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-66"><a href="#cb2-66"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb2-67"><a href="#cb2-67"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb2-70"><a href="#cb2-70"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb2-71"><a href="#cb2-71"></a>    <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb2-72"><a href="#cb2-72"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</span>
<span id="cb2-73"><a href="#cb2-73"></a></span>
<span id="cb2-74"><a href="#cb2-74"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb2-75"><a href="#cb2-75"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-76"><a href="#cb2-76"></a>    modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb2-77"><a href="#cb2-77"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb2-78"><a href="#cb2-78"></a></span>
<span id="cb2-79"><a href="#cb2-79"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb2-80"><a href="#cb2-80"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-81"><a href="#cb2-81"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb2-82"><a href="#cb2-82"></a>    modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb2-83"><a href="#cb2-83"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb2-84"><a href="#cb2-84"></a>    <span class="fu">return</span> e</span>
<span id="cb2-85"><a href="#cb2-85"></a></span>
<span id="cb2-86"><a href="#cb2-86"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb2-87"><a href="#cb2-87"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb2-88"><a href="#cb2-88"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb2-89"><a href="#cb2-89"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb2-90"><a href="#cb2-90"></a></span>
<span id="cb2-91"><a href="#cb2-91"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb2-92"><a href="#cb2-92"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-93"><a href="#cb2-93"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb2-94"><a href="#cb2-94"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb2-95"><a href="#cb2-95"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb2-96"><a href="#cb2-96"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb2-97"><a href="#cb2-97"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I didn’t notice a significant difference in speed on my inputs, but it’s good to know that the algorithm has been implemented with the correct asymptotics now!</p>
<p><em>Sidenote: A <code>Vector</code> of <code>Bool</code>s can be much more compactly represented as a sequence of 0s and 1s, which are just machine words. For implementations of this in Haskell, see the <a href="https://hackage.haskell.org/package/bv">bv</a> or <a href="https://hackage.haskell.org/package/bv-little">bv-little</a> packages. Using these could be another possible refactoring.</em></p>
<p>Looking at the code again, I notice some repetition of the form</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>x <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i</span>
<span id="cb3-2"><a href="#cb3-2"></a>y <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorY j</span>
<span id="cb3-3"><a href="#cb3-3"></a>write vectorZ k (<span class="dt">Just</span> (operation x y))</span></code></pre></div>
<p>and with the judicious use of <code>(=&lt;&lt;)</code> and <code>(&lt;*&gt;)</code> this can instead be</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>write vectorZ k <span class="op">=&lt;&lt;</span> (operation <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i <span class="op">&lt;*&gt;</span> <span class="fu">lookup</span> vectorY j)</span></code></pre></div>
<p>There are a couple of other places we could use <code>(&lt;*&gt;)</code>:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>(&lt;*&gt;)</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb5-16"><a href="#cb5-16"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb5-19"><a href="#cb5-19"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</span>
<span id="cb5-26"><a href="#cb5-26"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a>    readSTRef output</span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="kw">where</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-32"><a href="#cb5-32"></a></span>
<span id="cb5-33"><a href="#cb5-33"></a>strongConnect</span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb5-39"><a href="#cb5-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb5-40"><a href="#cb5-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb5-41"><a href="#cb5-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb5-42"><a href="#cb5-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb5-43"><a href="#cb5-43"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb5-44"><a href="#cb5-44"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb5-47"><a href="#cb5-47"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb5-48"><a href="#cb5-48"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb5-49"><a href="#cb5-49"></a>    push stack stackSet v</span>
<span id="cb5-50"><a href="#cb5-50"></a></span>
<span id="cb5-51"><a href="#cb5-51"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-53"><a href="#cb5-53"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb5-54"><a href="#cb5-54"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb5-55"><a href="#cb5-55"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-56"><a href="#cb5-56"></a>            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</span>
<span id="cb5-57"><a href="#cb5-57"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>                write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices w)</span>
<span id="cb5-59"><a href="#cb5-59"></a></span>
<span id="cb5-60"><a href="#cb5-60"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb5-61"><a href="#cb5-61"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</span>
<span id="cb5-62"><a href="#cb5-62"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-63"><a href="#cb5-63"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb5-64"><a href="#cb5-64"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb5-65"><a href="#cb5-65"></a></span>
<span id="cb5-66"><a href="#cb5-66"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb5-67"><a href="#cb5-67"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb5-68"><a href="#cb5-68"></a>    <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb5-69"><a href="#cb5-69"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</span>
<span id="cb5-70"><a href="#cb5-70"></a></span>
<span id="cb5-71"><a href="#cb5-71"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb5-72"><a href="#cb5-72"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-73"><a href="#cb5-73"></a>    modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb5-74"><a href="#cb5-74"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb5-75"><a href="#cb5-75"></a></span>
<span id="cb5-76"><a href="#cb5-76"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb5-77"><a href="#cb5-77"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-78"><a href="#cb5-78"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb5-79"><a href="#cb5-79"></a>    modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb5-80"><a href="#cb5-80"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb5-81"><a href="#cb5-81"></a>    <span class="fu">return</span> e</span>
<span id="cb5-82"><a href="#cb5-82"></a></span>
<span id="cb5-83"><a href="#cb5-83"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb5-84"><a href="#cb5-84"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb5-85"><a href="#cb5-85"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb5-86"><a href="#cb5-86"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb5-87"><a href="#cb5-87"></a></span>
<span id="cb5-88"><a href="#cb5-88"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb5-89"><a href="#cb5-89"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-90"><a href="#cb5-90"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb5-91"><a href="#cb5-91"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb5-92"><a href="#cb5-92"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb5-93"><a href="#cb5-93"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb5-94"><a href="#cb5-94"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>This is much nicer with the applicative combinators.</p>
<p>I would like to clean up that <code>when</code> as well, and for that I’d need a function like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>which is <a href="hackage.haskell.org/package/extra/docs/Control-Monad-Extra.html#v:whenM">available in Neil Mitchell’s <code>extra</code> package</a>.</p>
<p>I don’t think it’s worth pulling in that dependency though, so I’ll just copy that definition:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>whenM</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-15"><a href="#cb7-15"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb7-18"><a href="#cb7-18"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb7-21"><a href="#cb7-21"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb7-29"><a href="#cb7-29"></a></span>
<span id="cb7-30"><a href="#cb7-30"></a>    readSTRef output</span>
<span id="cb7-31"><a href="#cb7-31"></a>    <span class="kw">where</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-33"><a href="#cb7-33"></a></span>
<span id="cb7-34"><a href="#cb7-34"></a>strongConnect</span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-37"><a href="#cb7-37"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb7-39"><a href="#cb7-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb7-40"><a href="#cb7-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb7-42"><a href="#cb7-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb7-43"><a href="#cb7-43"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb7-44"><a href="#cb7-44"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb7-45"><a href="#cb7-45"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-46"><a href="#cb7-46"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb7-47"><a href="#cb7-47"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb7-48"><a href="#cb7-48"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb7-49"><a href="#cb7-49"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb7-50"><a href="#cb7-50"></a>    push stack stackSet v</span>
<span id="cb7-51"><a href="#cb7-51"></a></span>
<span id="cb7-52"><a href="#cb7-52"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb7-53"><a href="#cb7-53"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-54"><a href="#cb7-54"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb7-55"><a href="#cb7-55"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb7-56"><a href="#cb7-56"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb7-57"><a href="#cb7-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb7-58"><a href="#cb7-58"></a></span>
<span id="cb7-59"><a href="#cb7-59"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-60"><a href="#cb7-60"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb7-61"><a href="#cb7-61"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb7-62"><a href="#cb7-62"></a></span>
<span id="cb7-63"><a href="#cb7-63"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb7-64"><a href="#cb7-64"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb7-65"><a href="#cb7-65"></a>    <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb7-66"><a href="#cb7-66"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</span>
<span id="cb7-67"><a href="#cb7-67"></a></span>
<span id="cb7-68"><a href="#cb7-68"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb7-69"><a href="#cb7-69"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-70"><a href="#cb7-70"></a>    modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb7-71"><a href="#cb7-71"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb7-72"><a href="#cb7-72"></a></span>
<span id="cb7-73"><a href="#cb7-73"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb7-74"><a href="#cb7-74"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-75"><a href="#cb7-75"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb7-76"><a href="#cb7-76"></a>    modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb7-77"><a href="#cb7-77"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb7-78"><a href="#cb7-78"></a>    <span class="fu">return</span> e</span>
<span id="cb7-79"><a href="#cb7-79"></a></span>
<span id="cb7-80"><a href="#cb7-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb7-81"><a href="#cb7-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb7-82"><a href="#cb7-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb7-83"><a href="#cb7-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb7-84"><a href="#cb7-84"></a></span>
<span id="cb7-85"><a href="#cb7-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb7-86"><a href="#cb7-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-87"><a href="#cb7-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb7-88"><a href="#cb7-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb7-89"><a href="#cb7-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb7-90"><a href="#cb7-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb7-91"><a href="#cb7-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>Now I don’t actually even need <code>when</code> anymore!</p>
<p>Since most of the auxiliary functions aren’t used outside <code>strongConnect</code>, it might make sense to put them under a <code>where</code> clause. This would also make the parameters passed to <code>strongConnect</code> available to these functions. This is one place that the <code>ScopedTypeVariables</code> language extension is necessary, otherwise GHC can’t tell that the <code>s</code> in the type signature of <code>strongConnect</code> is the same <code>s</code> as the one in each type signature under the <code>where</code> clause.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>where</code></summary></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb8-16"><a href="#cb8-16"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb8-19"><a href="#cb8-19"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb8-22"><a href="#cb8-22"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb8-30"><a href="#cb8-30"></a></span>
<span id="cb8-31"><a href="#cb8-31"></a>    readSTRef output</span>
<span id="cb8-32"><a href="#cb8-32"></a>    <span class="kw">where</span></span>
<span id="cb8-33"><a href="#cb8-33"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-34"><a href="#cb8-34"></a></span>
<span id="cb8-35"><a href="#cb8-35"></a>strongConnect</span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="ot">    ::</span> <span class="kw">forall</span> s</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="op">.</span>  <span class="dt">Int</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb8-40"><a href="#cb8-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb8-41"><a href="#cb8-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb8-42"><a href="#cb8-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb8-44"><a href="#cb8-44"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb8-45"><a href="#cb8-45"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb8-46"><a href="#cb8-46"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb8-47"><a href="#cb8-47"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-48"><a href="#cb8-48"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb8-49"><a href="#cb8-49"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb8-50"><a href="#cb8-50"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb8-51"><a href="#cb8-51"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb8-52"><a href="#cb8-52"></a>    push v</span>
<span id="cb8-53"><a href="#cb8-53"></a></span>
<span id="cb8-54"><a href="#cb8-54"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-55"><a href="#cb8-55"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-56"><a href="#cb8-56"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb8-57"><a href="#cb8-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb8-58"><a href="#cb8-58"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb8-59"><a href="#cb8-59"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb8-60"><a href="#cb8-60"></a></span>
<span id="cb8-61"><a href="#cb8-61"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-62"><a href="#cb8-62"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb8-63"><a href="#cb8-63"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb8-64"><a href="#cb8-64"></a>    <span class="kw">where</span></span>
<span id="cb8-65"><a href="#cb8-65"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb8-66"><a href="#cb8-66"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb8-67"><a href="#cb8-67"></a>            <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb8-68"><a href="#cb8-68"></a>            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</span>
<span id="cb8-69"><a href="#cb8-69"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-70"><a href="#cb8-70"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-71"><a href="#cb8-71"></a>            modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb8-72"><a href="#cb8-72"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb8-73"><a href="#cb8-73"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb8-74"><a href="#cb8-74"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-75"><a href="#cb8-75"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb8-76"><a href="#cb8-76"></a>            modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb8-77"><a href="#cb8-77"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb8-78"><a href="#cb8-78"></a>            <span class="fu">return</span> e</span>
<span id="cb8-79"><a href="#cb8-79"></a></span>
<span id="cb8-80"><a href="#cb8-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb8-81"><a href="#cb8-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb8-82"><a href="#cb8-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb8-83"><a href="#cb8-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb8-84"><a href="#cb8-84"></a></span>
<span id="cb8-85"><a href="#cb8-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb8-86"><a href="#cb8-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-87"><a href="#cb8-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb8-88"><a href="#cb8-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb8-89"><a href="#cb8-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb8-90"><a href="#cb8-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb8-91"><a href="#cb8-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I think the logic is clearer now that the auxiliary functions take fewer arguments.</p>
<p>Instead of a large number of implictly related variables, it might be nice to define a single product type containing our entire environment and pass just one value around. With <code>NamedFieldPuns</code> only minimal code changes are required:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>NamedFieldPuns</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb9-15"><a href="#cb9-15"></a></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb9-19"><a href="#cb9-19"></a>    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb9-21"><a href="#cb9-21"></a>    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb9-22"><a href="#cb9-22"></a>    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb9-23"><a href="#cb9-23"></a>    }</span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb9-26"><a href="#cb9-26"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb9-27"><a href="#cb9-27"></a></span>
<span id="cb9-28"><a href="#cb9-28"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb9-29"><a href="#cb9-29"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-30"><a href="#cb9-30"></a>    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></span>
<span id="cb9-31"><a href="#cb9-31"></a>        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>        <span class="op">&lt;*&gt;</span> newSTRef []</span>
<span id="cb9-33"><a href="#cb9-33"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb9-35"><a href="#cb9-35"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb9-36"><a href="#cb9-36"></a>        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb9-37"><a href="#cb9-37"></a></span>
<span id="cb9-38"><a href="#cb9-38"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb9-39"><a href="#cb9-39"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v) <span class="op">$</span></span>
<span id="cb9-40"><a href="#cb9-40"></a>            strongConnect n v graph tarjanEnv</span>
<span id="cb9-41"><a href="#cb9-41"></a></span>
<span id="cb9-42"><a href="#cb9-42"></a>    readSTRef (output tarjanEnv)</span>
<span id="cb9-43"><a href="#cb9-43"></a>    <span class="kw">where</span></span>
<span id="cb9-44"><a href="#cb9-44"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-45"><a href="#cb9-45"></a></span>
<span id="cb9-46"><a href="#cb9-46"></a><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb9-47"><a href="#cb9-47"></a>strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output } <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-48"><a href="#cb9-48"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb9-49"><a href="#cb9-49"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb9-50"><a href="#cb9-50"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb9-51"><a href="#cb9-51"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb9-52"><a href="#cb9-52"></a>    push v</span>
<span id="cb9-53"><a href="#cb9-53"></a></span>
<span id="cb9-54"><a href="#cb9-54"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb9-55"><a href="#cb9-55"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-56"><a href="#cb9-56"></a>            strongConnect n w graph tarjanEnv</span>
<span id="cb9-57"><a href="#cb9-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb9-58"><a href="#cb9-58"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb9-59"><a href="#cb9-59"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb9-60"><a href="#cb9-60"></a></span>
<span id="cb9-61"><a href="#cb9-61"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-62"><a href="#cb9-62"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb9-63"><a href="#cb9-63"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb9-64"><a href="#cb9-64"></a>    <span class="kw">where</span></span>
<span id="cb9-65"><a href="#cb9-65"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb9-66"><a href="#cb9-66"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb9-67"><a href="#cb9-67"></a>            <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb9-68"><a href="#cb9-68"></a>            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</span>
<span id="cb9-69"><a href="#cb9-69"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb9-70"><a href="#cb9-70"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-71"><a href="#cb9-71"></a>            modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb9-72"><a href="#cb9-72"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb9-73"><a href="#cb9-73"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb9-74"><a href="#cb9-74"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-75"><a href="#cb9-75"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb9-76"><a href="#cb9-76"></a>            modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb9-77"><a href="#cb9-77"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb9-78"><a href="#cb9-78"></a>            <span class="fu">return</span> e</span>
<span id="cb9-79"><a href="#cb9-79"></a></span>
<span id="cb9-80"><a href="#cb9-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb9-81"><a href="#cb9-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb9-82"><a href="#cb9-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb9-83"><a href="#cb9-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb9-84"><a href="#cb9-84"></a></span>
<span id="cb9-85"><a href="#cb9-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb9-86"><a href="#cb9-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-87"><a href="#cb9-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb9-88"><a href="#cb9-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb9-89"><a href="#cb9-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb9-90"><a href="#cb9-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb9-91"><a href="#cb9-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>Let’s pause here. Although more refactoring is certainly possible, my last two steps did not reduce the line count and may have in fact made the code harder to understand.</p>
<p>How have we benefited from this refactoring? Aside from the code being shorter and better structured, it’s now easier to make meaningful improvements. For example, this implementation is more inefficient than it needs to be, because it doesn’t short-circuit when it finds that the current problem is unsatisfiable. Instead it works through the rest of the problem, only to throw all that work away. A sophisticated solution to this problem might involve the use of the <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Except.html"><code>ExceptT</code></a> monad transformer to throw an exception and exit early, but there is a simpler approach: we can store an extra boolean variable denoting whether or not the current problem is possibly satisfiable, and only continue working if it is. I’ll call this variable <code>possible</code>, update it in <code>addSCC</code>, and check for it before each call to <code>strongConnect</code> in <code>tarjan</code>. It takes more effort to reformat the code than to make this change:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs with short-circuiting</summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb10-19"><a href="#cb10-19"></a>    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb10-21"><a href="#cb10-21"></a>    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb10-22"><a href="#cb10-22"></a>    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb10-23"><a href="#cb10-23"></a>    ,<span class="ot"> possible ::</span> <span class="dt">STRef</span> s <span class="dt">Bool</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>    }</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb10-27"><a href="#cb10-27"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb10-28"><a href="#cb10-28"></a></span>
<span id="cb10-29"><a href="#cb10-29"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb10-30"><a href="#cb10-30"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>        <span class="op">&lt;*&gt;</span> newSTRef []</span>
<span id="cb10-34"><a href="#cb10-34"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb10-38"><a href="#cb10-38"></a>        <span class="op">&lt;*&gt;</span> newSTRef <span class="dt">True</span></span>
<span id="cb10-39"><a href="#cb10-39"></a></span>
<span id="cb10-40"><a href="#cb10-40"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>        whenM ((<span class="op">&amp;&amp;</span>)</span>
<span id="cb10-42"><a href="#cb10-42"></a>            <span class="op">&lt;$&gt;</span> ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v)</span>
<span id="cb10-43"><a href="#cb10-43"></a>            <span class="op">&lt;*&gt;</span> readSTRef (possible tarjanEnv)) <span class="op">$</span></span>
<span id="cb10-44"><a href="#cb10-44"></a>                strongConnect n v graph tarjanEnv</span>
<span id="cb10-45"><a href="#cb10-45"></a></span>
<span id="cb10-46"><a href="#cb10-46"></a>    readSTRef (output tarjanEnv)</span>
<span id="cb10-47"><a href="#cb10-47"></a>    <span class="kw">where</span></span>
<span id="cb10-48"><a href="#cb10-48"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-49"><a href="#cb10-49"></a></span>
<span id="cb10-50"><a href="#cb10-50"></a><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-51"><a href="#cb10-51"></a>strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output, possible } <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-52"><a href="#cb10-52"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb10-53"><a href="#cb10-53"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb10-54"><a href="#cb10-54"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb10-55"><a href="#cb10-55"></a>    modifySTRef' <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb10-56"><a href="#cb10-56"></a>    push v</span>
<span id="cb10-57"><a href="#cb10-57"></a></span>
<span id="cb10-58"><a href="#cb10-58"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb10-59"><a href="#cb10-59"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-60"><a href="#cb10-60"></a>            strongConnect n w graph tarjanEnv</span>
<span id="cb10-61"><a href="#cb10-61"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb10-62"><a href="#cb10-62"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb10-63"><a href="#cb10-63"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb10-64"><a href="#cb10-64"></a></span>
<span id="cb10-65"><a href="#cb10-65"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-66"><a href="#cb10-66"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb10-67"><a href="#cb10-67"></a>        modifySTRef' output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb10-68"><a href="#cb10-68"></a>    <span class="kw">where</span></span>
<span id="cb10-69"><a href="#cb10-69"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb10-70"><a href="#cb10-70"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc)</span>
<span id="cb10-71"><a href="#cb10-71"></a>            <span class="kw">then</span> writeSTRef possible <span class="dt">False</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb10-72"><a href="#cb10-72"></a>            <span class="kw">else</span></span>
<span id="cb10-73"><a href="#cb10-73"></a>                <span class="kw">let</span> scc' <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb10-74"><a href="#cb10-74"></a>                <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</span>
<span id="cb10-75"><a href="#cb10-75"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-76"><a href="#cb10-76"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-77"><a href="#cb10-77"></a>            modifySTRef' stack (e<span class="op">:</span>)</span>
<span id="cb10-78"><a href="#cb10-78"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb10-79"><a href="#cb10-79"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb10-80"><a href="#cb10-80"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-81"><a href="#cb10-81"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb10-82"><a href="#cb10-82"></a>            modifySTRef' stack <span class="fu">tail</span></span>
<span id="cb10-83"><a href="#cb10-83"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb10-84"><a href="#cb10-84"></a>            <span class="fu">return</span> e</span>
<span id="cb10-85"><a href="#cb10-85"></a></span>
<span id="cb10-86"><a href="#cb10-86"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb10-87"><a href="#cb10-87"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb10-88"><a href="#cb10-88"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb10-89"><a href="#cb10-89"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb10-90"><a href="#cb10-90"></a></span>
<span id="cb10-91"><a href="#cb10-91"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb10-92"><a href="#cb10-92"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-93"><a href="#cb10-93"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb10-94"><a href="#cb10-94"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb10-95"><a href="#cb10-95"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb10-96"><a href="#cb10-96"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb10-97"><a href="#cb10-97"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>This change does seem to make a significant difference, and it’s good to know we’re not doing useless work.</p>
<p>I think this is a good place to stop, and I hope I’ve been able to demonstrate some of Haskell’s strengths when it comes to refactoring. In my experience, it’s not usually necessary to deeply understand Haskell code in order to attempt a refactoring, especially if it’s backed by well-chosen types and a good test suite. I also find that I’m able to be more daring when writing new code, because bad up-front design is less costly and even the jankiest working code can be gently massaged into something presentable.</p>
<p><em>Thanks to <a href="https://joelburget.com/">Joel Burget</a>, <a href="http://www.matfournier.com/">Mat Fournier</a>, <a href="https://eskimor.gonimo.com/">Robert Klotzner</a>, <a href="https://github.com/L8D">Tenor</a>, <a href="http://www.tomharding.me/">Tom Harding</a>, and <a href="http://www.tylerweir.com/">Tyler Weir</a> for suggestions and feedback.</em></p>

        </div>
        <div id="footer">
            <div class="rc-webring">
                <a href="https://webring.recurse.com"><img src="https://webring.recurse.com/icon.png" /> RC Webring</a>
            </div>
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
        <script>
            (function() {
	        if (window.location.hostname.indexOf('localhost') > -1) {
                        return;
                }

                var script = document.createElement('script');
                window.counter = 'https://vaibhavsagar.goatcounter.com/count'
                script.async = 1;
                script.src = '//static.goatcounter.com/count.min.js';

                var ins = document.getElementsByTagName('script')[0];
                ins.parentNode.insertBefore(script, ins)
            })();
        </script>
    </body>
</html>
