<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Discovering Continuations with Typed Holes - Vaibhav Sagar</title>
        <link href="data:," rel="icon">
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../../../../about/">About</a>
                <a href="../../../../../talks/">Talks</a>
                <a href="../../../../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Discovering Continuations with Typed Holes</h1>

            <div class="info">
    Posted on 22 May 2017
    
</div>
<div class="info">
    
        Tags: <a href="../../../../../blog/tags/haskell/">haskell</a>, <a href="../../../../../blog/tags/programming/">programming</a>, <a href="../../../../../blog/tags/monads/">monads</a>
    
</div>

<p>I’ve been trying to wrap my head around continuations for a while. I was reading <a href="https://github.com/quchen/articles/blob/master/cont_monad.md">David Luposchainsky’s excellent article</a> on them and playing with his definitions in an IHaskell notebook when I found that typed holes are an excellent hammer to attack this particular nail with.</p>
<p>If you haven’t encountered them before, <a href="https://wiki.haskell.org/GHC/Typed_holes">typed holes</a> are a feature where you put one or more variables starting with <code>_</code> on the right hand side of a definition to get GHC to tell you the type of the value that fits in that hole, and you can narrow the hole as necessary to get the type of a subexpression until you have enough information to complete the definition. I like to think of this as a way of collaboratively filling in a definition with the compiler, instead of my usual approach which is to write a definition, listen carefully to GHC’s complaints, and amend my definition accordingly. Typed holes are fully supported by GHCi and the full suite of editor integrations, but I personally find the edit/reload/squint cycle more tedious than coming up with the definition in IHaskell and then moving it to a module and adding type signatures after I’m satisfied that it works.</p>
<p>IHaskell has HLint integration and will suggest corrections for my intermediate cells unless I turn that off:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">:</span>option no<span class="op">-</span>lint</span></code></pre></div>
<p>There’s a useful GHC extension called <code>InstanceSigs</code> that will allow me to annotate my typeclass instances with their type signatures, so I’ll turn that on:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></span></code></pre></div>
<p>I think his type definition makes an excellent starting point:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> (&gt;&gt;-) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</span></code></pre></div>
<p>This defines a type <code>Cont</code> with an infix constructor <code>&gt;&gt;-</code> (that looks suspiciously similar to <code>&gt;&gt;=</code>) that takes a function from <code>a</code> to <code>r</code> and provides an <code>r</code>. One intuition for what this means is that a value of this type knows about an <code>a</code> but for whatever reason refuses to be upfront about it and demands to know what you’re going to do with it and then does it for you, providing you with a final result <code>r</code>. Another intuition is that this is a generalisation of callbacks: a value of this type expects a callback to utilise the <code>a</code>. Anyway, on to my favourite part of working with mysterious data types: defining <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances for them! If you’ve done this before, you’ll know that these typeclasses have certain laws that their instances are meant to obey, and it turns out that this type is polymorphic enough that we can just follow the typed holes and the resulting definitions will be lawful. You don’t have to take my word for it and should verify this for yourself, but I won’t be discussing the laws here. Let’s begin!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:19: error:
    • Found hole: _ :: Cont r b
      Where: ‘b’ is a rigid type variable bound by
               the type signature for:
                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b
               at &lt;interactive&gt;:2:13-44
             ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-25
    • In the expression: _
      In an equation for ‘fmap’: fmap f cont = _
      In the instance declaration for ‘Functor (Cont r)’
    • Relevant bindings include
        cont :: Cont r a (bound at &lt;interactive&gt;:3:12)
        f :: a -&gt; b (bound at &lt;interactive&gt;:3:10)
        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</code></pre>
<p>We didn’t really need a typed hole to tell us this, but at least we know what we have to work with. We know we have to provide a <code>Cont</code> value, so let’s narrow our typed hole that way.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:26: error:
    • Found hole: _ :: (b -&gt; r) -&gt; r
      Where: ‘b’ is a rigid type variable bound by
               the type signature for:
                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b
               at &lt;interactive&gt;:2:13-44
             ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-25
    • In the second argument of ‘($)’, namely ‘_’
      In the expression: Cont $ _
      In an equation for ‘fmap’: fmap f cont = Cont $ _
    • Relevant bindings include
        cont :: Cont r a (bound at &lt;interactive&gt;:3:12)
        f :: a -&gt; b (bound at &lt;interactive&gt;:3:10)
        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</code></pre>
<p>The type of our hole is more helpful here. Now we know (if we were previously uncertain) that we somehow need to use <code>f</code> to turn the <code>a</code> into a <code>b</code>. We also know that <code>Cont</code> takes a parameter, let’s add that in and see if it helps.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:32: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-25
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k -&gt; _’
      In the expression: Cont $ \ k -&gt; _
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:3:27)
        cont :: Cont r a (bound at &lt;interactive&gt;:3:12)
        f :: a -&gt; b (bound at &lt;interactive&gt;:3:10)
        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</code></pre>
<p>In general, we know all of our definitions will be of the form <code>Cont $ \k -&gt; _</code> and that’s a safe starting point. We now know that we need to use <code>k</code> on the result of applying <code>f</code> to some <code>a</code> to finally result in an <code>r</code>, but where does the <code>a</code> come from? The only thing we can do at this point is ‘unwrap’ the <code>cont</code> using <code>&gt;&gt;-</code>. What happens when we do that?</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> cont <span class="op">&gt;&gt;-</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:41: error:
    • Found hole: _ :: a -&gt; r
      Where: ‘a’ is a rigid type variable bound by
               the type signature for:
                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b
               at &lt;interactive&gt;:2:13-44
             ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-25
    • In the second argument of ‘&gt;&gt;-’, namely ‘_’
      In the expression: cont &gt;&gt;- _
      In the second argument of ‘($)’, namely ‘\ k -&gt; cont &gt;&gt;- _’
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:3:27)
        cont :: Cont r a (bound at &lt;interactive&gt;:3:12)
        f :: a -&gt; b (bound at &lt;interactive&gt;:3:10)
        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</code></pre>
<p>It looks like we might have everything we need to complete this definition! We can create a function of type <code>a -&gt; r</code> by composing <code>k</code> and <code>f</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> cont <span class="op">&gt;&gt;-</span> (k <span class="op">.</span> f)</span></code></pre></div>
<p>It worked! This definition states that <code>fmap</code> works by creating a continuation that expects a callback of the new type. This is pretty exciting! Let’s continue to <code>Applicative</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:27: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-29
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k -&gt; _’
      In the expression: Cont $ \ k -&gt; _
    • Relevant bindings include
        k :: a -&gt; r (bound at &lt;interactive&gt;:3:22)
        a :: a (bound at &lt;interactive&gt;:3:10)
        pure :: a -&gt; Cont r a (bound at &lt;interactive&gt;:3:5)</code></pre>
<p>That was pretty easy. We need an <code>r</code> and we have an <code>a</code> and a <code>k</code> that takes an <code>a</code> to an <code>r</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span></code></pre></div>
<p>This matches our intuition from above: creating a continuation involves hiding a value behind a function that can access it. On to <code>&lt;*&gt;</code>!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Cont</span> r (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb16-5"><a href="#cb16-5"></a>    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:5:28: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-29
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k -&gt; _’
      In the expression: Cont $ \ k -&gt; _
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:5:23)
        a :: Cont r a (bound at &lt;interactive&gt;:5:11)
        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:5:5)
        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:5:7)</code></pre>
<p>From above, we know we can ‘unwrap’ <code>Cont</code> values using <code>&gt;&gt;-</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Cont</span> r (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb18-5"><a href="#cb18-5"></a>    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f <span class="op">&gt;&gt;-</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:5:34: error:
    • Found hole: _ :: (a -&gt; b) -&gt; r
      Where: ‘a’, ‘b’ are rigid type variables bound by
               the type signature for:
                 (&lt;*&gt;) :: forall a b. Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b
               at &lt;interactive&gt;:4:14-52
             ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-29
    • In the second argument of ‘&gt;&gt;-’, namely ‘_’
      In the expression: f &gt;&gt;- _
      In the second argument of ‘($)’, namely ‘\ k -&gt; f &gt;&gt;- _’
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:5:23)
        a :: Cont r a (bound at &lt;interactive&gt;:5:11)
        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:5:5)
        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:5:7)</code></pre>
<p>Let’s keep going.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Cont</span> r (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb20-5"><a href="#cb20-5"></a>    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:5:54: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-29
    • In the expression: _
      In the second argument of ‘&gt;&gt;-’, namely ‘\ a' -&gt; _’
      In the expression: a &gt;&gt;- \ a' -&gt; _
    • Relevant bindings include
        a' :: a (bound at &lt;interactive&gt;:5:48)
        f' :: a -&gt; b (bound at &lt;interactive&gt;:5:35)
        k :: b -&gt; r (bound at &lt;interactive&gt;:5:23)
        a :: Cont r a (bound at &lt;interactive&gt;:5:11)
        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:5:5)
        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:5:7)</code></pre>
<p>Perfect, we want an <code>r</code> and we have</p>
<ul>
<li>an <code>a</code> (<code>a'</code>)</li>
<li>a function from <code>a</code> to <code>b</code> (<code>f'</code>)</li>
<li>a function from <code>b</code> to <code>r</code> (<code>k</code>)</li>
</ul>
<p>Let’s put them together.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Cont</span> r (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb22-5"><a href="#cb22-5"></a>    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> k (f' a')</span></code></pre></div>
<p>Okay, we unwrap the function and the argument and rewrap them in a fresh continuation, not too differently from how we defined <code>fmap</code>. Sweet! On to the big M!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb23-3"><a href="#cb23-3"></a>    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:28: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-23
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k -&gt; _’
      In the expression: Cont $ \ k -&gt; _
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)
        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:3:11)
        a :: Cont r a (bound at &lt;interactive&gt;:3:5)
        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:3:7)</code></pre>
<p>As before, our first order of business is to unwrap the <code>a</code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb25-3"><a href="#cb25-3"></a>    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:41: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-23
    • In the expression: _
      In the second argument of ‘&gt;&gt;-’, namely ‘\ a' -&gt; _’
      In the expression: a &gt;&gt;- \ a' -&gt; _
    • Relevant bindings include
        a' :: a (bound at &lt;interactive&gt;:3:35)
        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)
        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:3:11)
        a :: Cont r a (bound at &lt;interactive&gt;:3:5)
        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:3:7)</code></pre>
<p>We can apply <code>f</code> to this unwrapped value to get a continuation that we can unwrap again.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb27-3"><a href="#cb27-3"></a>    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> f a' <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:3:57: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the instance declaration
               at &lt;interactive&gt;:1:10-23
    • In the expression: _
      In the second argument of ‘&gt;&gt;-’, namely ‘\ f' -&gt; _’
      In the expression: f a' &gt;&gt;- \ f' -&gt; _
    • Relevant bindings include
        f' :: b (bound at &lt;interactive&gt;:3:51)
        a' :: a (bound at &lt;interactive&gt;:3:35)
        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)
        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:3:11)
        a :: Cont r a (bound at &lt;interactive&gt;:3:5)
        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:3:7)</code></pre>
<p>We want an <code>r</code> and we have <code>k</code> and <code>f'</code>. Let’s put them together!</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb29-3"><a href="#cb29-3"></a>    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> f a' <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> k f'</span></code></pre></div>
<p>And that’s it! The <a href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">mother of all monads</a> boils down to some tedious and almost mechanical wrapping and unwrapping. I think it’s cool how mundane it is.</p>
<p>Let’s have a crack at something more involved. A lot of the magic in continuations is accessed via <code>callCC</code>, which takes a function and calls it with the current continuation, hence the name. How would we define it?</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb30-2"><a href="#cb30-2"></a>callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> _</span></code></pre></div>
<pre><code>&lt;interactive&gt;:2:25: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the type signature for:
                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b
               at &lt;interactive&gt;:1:1-51
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k -&gt; _’
      In the expression: Cont $ \ k -&gt; _
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)
        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)
        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</code></pre>
<p>Our definition involves <code>b</code>, but the only <code>b</code> we have available is wrapped up in <code>f</code>. We need to provide an argument of a certain type to <code>f</code>, and then unwrap the result of that? Time to bring out the big guns: multiple typed holes!</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb32-2"><a href="#cb32-2"></a>callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f _1 <span class="op">&gt;&gt;-</span> _2</span></code></pre></div>
<pre><code>&lt;interactive&gt;:2:27: error:
    • Found hole: _1 :: b -&gt; Cont r a
      Where: ‘b’, ‘r’, ‘a’ are rigid type variables bound by
               the type signature for:
                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b
               at &lt;interactive&gt;:1:1-51
      Or perhaps ‘_1’ is mis-spelled, or not in scope
    • In the first argument of ‘f’, namely ‘_1’
      In the first argument of ‘&gt;&gt;-’, namely ‘f _1’
      In the expression: f _1 &gt;&gt;- _2
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)
        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)
        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)
&lt;interactive&gt;:2:34: error:
    • Found hole: _2 :: b -&gt; r
      Where: ‘b’, ‘r’ are rigid type variables bound by
               the type signature for:
                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b
               at &lt;interactive&gt;:1:1-51
      Or perhaps ‘_2’ is mis-spelled, or not in scope
    • In the second argument of ‘&gt;&gt;-’, namely ‘_2’
      In the expression: f _1 &gt;&gt;- _2
      In the second argument of ‘($)’, namely ‘\ k -&gt; f _1 &gt;&gt;- _2’
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)
        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)
        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)
      Valid hole fits include k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)</code></pre>
<p>Great, <code>k</code> fits perfectly into the second hole. That was easy.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb34-2"><a href="#cb34-2"></a>callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f _ <span class="op">&gt;&gt;-</span> k</span></code></pre></div>
<pre><code>&lt;interactive&gt;:2:27: error:
    • Found hole: _ :: b -&gt; Cont r a
      Where: ‘b’, ‘r’, ‘a’ are rigid type variables bound by
               the type signature for:
                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b
               at &lt;interactive&gt;:1:1-51
    • In the first argument of ‘f’, namely ‘_’
      In the first argument of ‘&gt;&gt;-’, namely ‘f _’
      In the expression: f _ &gt;&gt;- k
    • Relevant bindings include
        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)
        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)
        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</code></pre>
<p>We’re being asked to provide a function that takes one argument and returns a continuation. Let’s fill in the boilerplate and see where that takes us.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb36-2"><a href="#cb36-2"></a>callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="op">$</span> \k' <span class="ot">-&gt;</span> _) <span class="op">&gt;&gt;-</span> k</span></code></pre></div>
<pre><code>&lt;interactive&gt;:2:48: error:
    • Found hole: _ :: r
      Where: ‘r’ is a rigid type variable bound by
               the type signature for:
                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b
               at &lt;interactive&gt;:1:1-51
    • In the expression: _
      In the second argument of ‘($)’, namely ‘\ k' -&gt; _’
      In the expression: Cont $ \ k' -&gt; _
    • Relevant bindings include
        k' :: a -&gt; r (bound at &lt;interactive&gt;:2:42)
        b :: b (bound at &lt;interactive&gt;:2:29)
        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)
        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)
        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</code></pre>
<p>And we’re done! We can get an <code>r</code> by applying <code>k</code> to <code>b</code>.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b</span>
<span id="cb38-2"><a href="#cb38-2"></a>callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="op">$</span> \k' <span class="ot">-&gt;</span> k b) <span class="op">&gt;&gt;-</span> k</span></code></pre></div>
<p>A closer look at the definition reveals that <code>k'</code> is unused, and this function provides <code>f</code> with the option to exit early if desired, or continue as normal. There’s a good explanation of why and how this works at <a href="https://github.com/quchen/articles/blob/master/cont_monad.md#special-api-function-callcc">the aforementioned article</a>.</p>
<p>Still a bit wary? That’s fair. I like to poke at the definitions, <a href="https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Cont.html">read the source</a>, look at how Gabriel Gonzales <a href="http://www.haskellforall.com/2014/04/how-continuation-monad-works.html">explains it</a>, and have a cup of tea and think about life for a while. Whatever works for you!</p>
<p>If you looked at the source, you might have noticed something interesting: The definition for the ContT monad transformer is identical! Here it is below.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">newtype</span> <span class="dt">ContT</span> r m a <span class="ot">=</span> <span class="dt">ContT</span> {<span class="ot"> (&gt;&gt;-) ::</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r }</span>
<span id="cb39-2"><a href="#cb39-2"></a></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b</span>
<span id="cb39-5"><a href="#cb39-5"></a>    <span class="fu">fmap</span> f cont <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> cont <span class="op">&gt;&gt;-</span> (k <span class="op">.</span> f)</span>
<span id="cb39-6"><a href="#cb39-6"></a></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a</span>
<span id="cb39-9"><a href="#cb39-9"></a>    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">ContT</span> r m (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b</span>
<span id="cb39-11"><a href="#cb39-11"></a>    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> k (f' a')</span>
<span id="cb39-12"><a href="#cb39-12"></a></span>
<span id="cb39-13"><a href="#cb39-13"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span></span>
<span id="cb39-14"><a href="#cb39-14"></a><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">ContT</span> r m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b</span>
<span id="cb39-15"><a href="#cb39-15"></a>    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> a <span class="op">&gt;&gt;-</span> \a' <span class="ot">-&gt;</span> f a' <span class="op">&gt;&gt;-</span> \f' <span class="ot">-&gt;</span> k f'</span>
<span id="cb39-16"><a href="#cb39-16"></a>    </span>
<span id="cb39-17"><a href="#cb39-17"></a><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b</span>
<span id="cb39-18"><a href="#cb39-18"></a>callCC f <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="op">$</span> \k' <span class="ot">-&gt;</span> k b) <span class="op">&gt;&gt;-</span> k</span></code></pre></div>
<p>I love being able to interact with these definitions like this. This is really how I want to program, and I’d encourage you to try it! The notebook is <a href="https://github.com/vaibhavsagar/notebooks/blob/master/continuations/Continuation.ipynb">here</a> for you to play with if you have IHaskell set up. IHaskell isn’t just useful for programming: I even used it to <a href="https://github.com/vaibhavsagar/notebooks/blob/master/continuations/DiscoveringContinuationsWithTypedHoles.ipynb">write this blog post</a>!</p>
<p>I feel like I should end with something profound about continuations, but I’ll instead link you to <a href="http://teh.id.au/posts/2017/05/10/lambdajam-slides/">this presentation by Tim Humphries</a> and once again nudge you to try typed holes the next time you’re in a Haskell bind (pun very much intended).</p>
<p>Thanks to <a href="https://twitter.com/imccoy">Iain McCoy</a>, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="https://ivanthetricourne.github.io/">Carl Factora</a> for their feedback and suggestions on this post.</p>

        </div>
        <div id="footer">
            <div class="rc-webring">
                <a href="https://webring.recurse.com"><img src="https://webring.recurse.com/icon.png" /> RC Webring</a>
            </div>
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
        <script data-goatcounter="https://vaibhavsagar.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
    </body>
</html>
