<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Lazy Functional State Threads - Vaibhav Sagar</title>
        <link href="data:," rel="icon">
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../about/">About</a>
                <a href="../../talks/">Talks</a>
                <a href="../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Lazy Functional State Threads</h1>

            <div class="info">
    Posted on 19 June 2017
    
</div>
<div class="info">
    
        Tags: <a title="All pages tagged 'haskell'." href="../../blog/tags/haskell/" rel="tag">haskell</a>, <a title="All pages tagged 'programming'." href="../../blog/tags/programming/" rel="tag">programming</a>, <a title="All pages tagged 'monads'." href="../../blog/tags/monads/" rel="tag">monads</a>
    
</div>

<p>A funny thing happened when I was writing my Imperative Haskell post: after
railing against Haskell’s tendency to tell you to go off and read a paper when
introducing a library, I did exactly that and read ‘Lazy Functional State
Threads’ and found it relatively accessible. I signed myself up to present it
at Papers We Love SG, and as a way of clarifying what I want to talk about, I’m
going to try to summarise it here.</p>
<p>The paper begins by admitting that we sometimes want to express strict stateful
computations in a purely-functional language efficiently. We want to do this
<a href="http://www.threewordphrase.com/pardonme.gif">because of reasons</a>. Some
examples of algorithms we’d like to express are those based on mutable hash
tables, union find, and especially input/output. However, the language we are
working with is renowned for its laziness, which means the order of evaluation
can be counterintuitive, and its referential transparency, which means a lack
of side effects.</p>
<p>We square this circle by leveraging the type system, which simultaneously
allows most of the features we take for granted in imperative languages
(multiple named variables, in-place updates) as well as being encapsulated and
referentially transparent (for certain values of referentially transparent).
Let’s define a ‘state transformer’ that takes an initial state as input and
returns a final state. This can be represented as a value of type <code>ST s a</code>
where <code>s</code> is the state type and <code>a</code> is the return type.</p>
<!-- picture of state transformer -->
<p>A state transformer can have multiple inputs (multiple arguments to a function)
and multiple outputs (a tuple).</p>
<!-- picture of multiple input/output state transformer -->
<p>The simplest state transformer takes a value of type <code>a</code> and sticks it in a
state transformer. We’ll call it <code>returnST</code>.</p>
<!-- picture of returnST -->
<p>Let’s talk about ‘state’ now, specifically mutable variables or references.
Let’s specify an API for working with references:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">newVar</span><span>   </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span class="ot">)</span><span>
</span><span class="va">readVar</span><span>  </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="va">writeVar</span><span> </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span></code></pre></div>
<p>In other words, <code>newVar</code> takes a value of type <code>a</code> and returns a state
transformer that can be supplied a state to output a new state containing a
fresh reference to the provided value. <code>readVar</code> is a state transformer which
leaves the provided state unchanged but extracts the value in the reference
from it. <code>writeVar</code> takes a reference and a new value and returns a state
transformer that updates the reference to point to the new value. The fact that
the return value is <code>()</code> indicates that this state transformer is only useful
for its effect on the state.</p>
<p>To compose these state transformers together we can define a <code>thenST</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">thenST</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">b</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">b</span></code></pre></div>
<!-- picture of thenST -->
<p>Two things to note here: both <code>s1</code> and <code>s2</code> have to work with the same state
type <code>s</code>, and they way they work is inherently sequential, because the output
of <code>s1</code> is the input of <code>s2</code>. This is where ‘thread’ in the title comes from. I
like to think of this as the baton in a relay: you can’t run when you’re not
holding the baton, and you can’t use a different team’s baton because that’s
against the rules.</p>
<p>While we let that sink in, I’d like to make a brief historical digression. At
this stage in Haskell’s history, monads had been identified as a useful
abstraction and a predecessor to this paper had proposed a particular syntax
for working with them, but do-notation had not yet made its way into the
language. If you’re not familiar with monads, you can think of them as an
interface for a type defined by two functions, <code>return</code> and <code>&gt;&gt;=</code>
(pronounced ‘bind’) and certain laws that these functions must obey:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span><span> </span><span class="dt">Monad</span><span> </span><span class="va">m</span><span> </span><span class="kw">where</span><span>
    </span><span class="va">return</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span>
    </span><span class="ot">(</span><span class="op">&gt;&gt;=</span><span class="ot">)</span><span>  </span><span class="ot">::</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span></code></pre></div>
<p>The actual definition differs slightly in ways that aren’t relevant here. Why
do I bring this up? If you look closely, we’ve encountered functions that look
very similar to the two above. If we textually replace <code>m</code> with <code>ST s</code>, we get</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">return</span><span> </span><span class="ot">::</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="ot">(</span><span class="op">&gt;&gt;=</span><span class="ot">)</span><span>  </span><span class="ot">::</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">b</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">b</span></code></pre></div>
<p>which are exactly the type signatures of <code>returnST</code> and <code>thenST</code>. This isn’t a
coincidence. I will also claim (but not prove) that these definitions are
law-abiding.</p>
<p>What can we do with this information? Let’s take this code snippet that swaps
the contents of two references:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">swap</span><span> </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">swap</span><span> </span><span class="va">v</span><span> </span><span class="va">w</span><span> </span><span class="ot">=</span><span> </span><span class="va">readVar</span><span> </span><span class="va">v</span><span>    </span><span class="ot">`</span><span class="va">thenST</span><span class="ot">`</span><span> </span><span class="ot">(</span><span class="ot">\</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span>
           </span><span class="va">readVar</span><span> </span><span class="va">w</span><span>    </span><span class="ot">`</span><span class="va">thenST</span><span class="ot">`</span><span> </span><span class="ot">(</span><span class="ot">\</span><span class="va">b</span><span> </span><span class="ot">-&gt;</span><span>
           </span><span class="va">writeVar</span><span> </span><span class="va">v</span><span> </span><span class="va">b</span><span> </span><span class="ot">`</span><span class="va">thenST</span><span class="ot">`</span><span> </span><span class="ot">(</span><span class="ot">\</span><span class="ot">_</span><span> </span><span class="ot">-&gt;</span><span>
           </span><span class="va">writeVar</span><span> </span><span class="va">w</span><span> </span><span class="va">a</span><span class="ot">)</span><span class="ot">)</span><span class="ot">)</span></code></pre></div>
<p>This requires working with infix backticks and lambdas and looks pretty ugly,
but we can do better! We have do-notation which is syntax sugar that converts</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span><span> </span><span class="va">x</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">f</span><span>
   </span><span class="va">y</span></code></pre></div>
<p>into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">f</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="ot">(</span><span class="ot">\</span><span class="va">x</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">y</span><span class="ot">)</span></code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span><span> </span><span class="va">x</span><span>
   </span><span class="va">y</span></code></pre></div>
<p>into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">x</span><span> </span><span class="op">&gt;&gt;</span><span> </span><span class="va">y</span></code></pre></div>
<p>where <code>&gt;&gt;</code> is like <code>&gt;&gt;=</code> that ignores the output of the left hand side:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(</span><span class="op">&gt;&gt;</span><span class="ot">)</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Monad</span><span> </span><span class="va">m</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">m</span><span> </span><span class="va">b</span><span>
</span><span class="ot">(</span><span class="op">&gt;&gt;</span><span class="ot">)</span><span> </span><span class="va">ma</span><span> </span><span class="va">mb</span><span> </span><span class="ot">=</span><span> </span><span class="va">ma</span><span> </span><span class="op">&gt;&gt;=</span><span> </span><span class="ot">(</span><span class="ot">\</span><span class="ot">_</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">mb</span><span class="ot">)</span></code></pre></div>
<p>Armed with this knowledge, we can rewrite the above example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">swap</span><span> </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">swap</span><span> </span><span class="va">v</span><span> </span><span class="va">w</span><span> </span><span class="ot">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readVar</span><span> </span><span class="va">v</span><span>
    </span><span class="va">b</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readVar</span><span> </span><span class="va">w</span><span>
    </span><span class="va">writeVar</span><span> </span><span class="va">v</span><span> </span><span class="va">b</span><span>
    </span><span class="va">writeVar</span><span> </span><span class="va">w</span><span> </span><span class="va">a</span></code></pre></div>
<p>Much better! We even define <code>(&gt;&gt;)</code> directly as <code>thenST_</code>. The rest of the code
samples in this post will use do-notation.</p>
<p>The authors also mention the existence of <code>fixST</code>, but this isn’t discussed
elsewhere in the paper so I’ll skip that.</p>
<p>We now move to the other main contribution of the paper, which is the matter of
how to prevent state from leaking out of our state transformers. The naive
approach would be to define a <code>runST</code> that would provide an initial state as
follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">runST</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span></code></pre></div>
<p>But this would allow leakage as in the following example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span><span> </span><span class="va">v</span><span> </span><span class="ot">=</span><span> </span><span class="va">runST</span><span> </span><span class="ot">(</span><span class="va">newVar</span><span> </span><span class="dt">True</span><span class="ot">)</span><span>
</span><span class="kw">in</span><span>
</span><span class="va">runST</span><span> </span><span class="ot">(</span><span class="va">readVar</span><span> </span><span class="va">v</span><span class="ot">)</span></code></pre></div>
<p>and because Haskell is a lazy language, we cannot enforce an ordering on
updates to the state. What we really want is for our <code>runST</code> to work <em>regardless
of which initial state it was given</em>, and we can encode that in the type
signature with rank-2 polymorphism as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">runST</span><span> </span><span class="ot">::</span><span> </span><span class="kw">∀</span><span class="va">a</span><span class="op">.</span><span> </span><span class="ot">(</span><span class="kw">∀</span><span class="va">s</span><span class="op">.</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span></code></pre></div>
<p>We can read ∀ as ‘forall’ and this is rank-2 because <code>s</code> is scoped within the
parentheses and we can’t move it outside without changing the meaning of the
type signature. We can read this as ‘for any <code>a</code>, given a state transformer
that would work with any <code>s</code>, provide it with some state and extract the <code>a</code>’.
Our previous example no longer typechecks, because <code>v</code> does not have the type
<code>∀s.ST s a</code>, and we can see that the typechecker enforces our requirement that
the state cannot leak out of the state transformer, hence ensuring referential
transparency. This definition still allows useful code such as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">f</span><span> </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span>
</span><span class="va">f</span><span> </span><span class="va">v</span><span> </span><span class="ot">=</span><span> </span><span class="va">runST</span><span> </span><span class="op">$</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">w</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">newVar</span><span> </span><span class="va">v</span><span>
    </span><span class="va">readVar</span><span> </span><span class="va">w</span></code></pre></div>
<p>which works because <code>v</code> is never dereferenced.</p>
<p>We can generalise our references to consider an array of mutable references. An
API for this could look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">newArr</span><span>    </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">i</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">elt</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">elt</span><span class="ot">)</span><span>
</span><span class="va">readArr</span><span>   </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">elt</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">i</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">elt</span><span>
</span><span class="va">writeArr</span><span>  </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">elt</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">i</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">elt</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">freezeArr</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">elt</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="dt">Array</span><span> </span><span class="va">i</span><span> </span><span class="va">elt</span><span class="ot">)</span></code></pre></div>
<p>This is very similar to our API for references, but parametrised over the index
type <code>i</code> and including a function <code>freezeArr</code> that looks up the current value
of a mutable array in the state and returns an immutable copy of it.</p>
<p>With this API, we can define <code>accumArray</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">accumArray</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">b</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">i</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">b</span><span class="ot">)</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Array</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span></code></pre></div>
<p>This takes a function, an initial value, array bounds, and a list of indexed
values, and does a left fold over each indexed value, putting the result at the
associated index. This can be used to compute a histogram:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">hist</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">i</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">[</span><span class="va">i</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Array</span><span> </span><span class="va">i</span><span> </span><span class="dt">Int</span><span>
</span><span class="va">hist</span><span> </span><span class="va">bnds</span><span> </span><span class="va">is</span><span> </span><span class="ot">=</span><span> </span><span class="va">accumArray</span><span> </span><span class="ot">(</span><span class="op">+</span><span class="ot">)</span><span> </span><span class="dv">0</span><span> </span><span class="va">bnds</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="dv">1</span><span class="ot">)</span><span> </span><span class="ot">|</span><span> </span><span class="va">i</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">is</span><span class="ot">,</span><span> </span><span class="va">inRange</span><span> </span><span class="va">bnds</span><span> </span><span class="va">i</span><span class="ot">]</span></code></pre></div>
<p>that counts occurrences of elements in <code>is</code> within the bounds provided or
<code>binSort</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">binSort</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span class="va">i</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">i</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">[</span><span class="va">a</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Array</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span>
</span><span class="va">binSort</span><span> </span><span class="va">bnds</span><span> </span><span class="va">key</span><span> </span><span class="va">vs</span><span> </span><span class="ot">=</span><span> </span><span class="va">accumArray</span><span> </span><span class="ot">(</span><span class="va">flip</span><span> </span><span class="ot">(</span><span class="ot">:</span><span class="ot">)</span><span class="ot">)</span><span> </span><span class="ot">[</span><span class="ot">]</span><span> </span><span class="va">bnds</span><span> </span><span class="ot">[</span><span class="ot">(</span><span class="va">key</span><span> </span><span class="va">v</span><span class="ot">,</span><span> </span><span class="va">v</span><span class="ot">)</span><span> </span><span class="ot">|</span><span> </span><span class="va">v</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">vs</span><span class="ot">]</span></code></pre></div>
<p>that puts each element of <code>vs</code> into a bin based on its <code>key</code>. <code>accumArray</code> can
be defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">accumArray</span><span> </span><span class="va">f</span><span> </span><span class="va">z</span><span> </span><span class="va">bnds</span><span> </span><span class="va">ivs</span><span> </span><span class="ot">=</span><span> </span><span class="va">runST</span><span> </span><span class="op">$</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">newArr</span><span> </span><span class="va">bnds</span><span> </span><span class="va">z</span><span>
    </span><span class="va">fill</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span> </span><span class="va">ivs</span><span>
    </span><span class="va">freezeArr</span><span> </span><span class="va">a</span><span>

</span><span class="va">fill</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span> </span><span class="ot">[</span><span class="ot">]</span><span>          </span><span class="ot">=</span><span> </span><span class="va">return</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">fill</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span> </span><span class="ot">(</span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span class="va">v</span><span class="ot">)</span><span class="ot">:</span><span class="va">ivs</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">x</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readArr</span><span> </span><span class="va">a</span><span> </span><span class="va">i</span><span>
    </span><span class="va">writeArr</span><span> </span><span class="va">a</span><span> </span><span class="va">i</span><span> </span><span class="ot">(</span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="va">v</span><span class="ot">)</span><span>
    </span><span class="va">fill</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span> </span><span class="va">ivs</span></code></pre></div>
<p>This is a good example of a function that is internally imperative but
externally pure.</p>
<p>If we define a function to sequence state transformers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">seqST</span><span> </span><span class="ot">::</span><span> </span><span class="ot">[</span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span><span class="ot">]</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">seqST</span><span> </span><span class="ot">=</span><span> </span><span class="va">sequence_</span><span> </span><span class="co">-- originally defined as `foldr (&gt;&gt;) (return ())`</span></code></pre></div>
<p>then we can rewrite <code>accumArray</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">accumArray</span><span> </span><span class="va">f</span><span> </span><span class="va">z</span><span> </span><span class="va">bnds</span><span> </span><span class="va">ivs</span><span> </span><span class="ot">=</span><span> </span><span class="va">runST</span><span> </span><span class="op">$</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">a</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">newArr</span><span> </span><span class="va">bnds</span><span> </span><span class="va">z</span><span>
    </span><span class="va">seqST</span><span> </span><span class="ot">(</span><span class="va">map</span><span> </span><span class="ot">(</span><span class="va">update</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span class="ot">)</span><span> </span><span class="va">ivs</span><span class="ot">)</span><span>
    </span><span class="va">freezeArr</span><span> </span><span class="va">s</span><span>

</span><span class="va">update</span><span> </span><span class="va">a</span><span> </span><span class="va">f</span><span> </span><span class="ot">(</span><span class="va">i</span><span class="ot">,</span><span> </span><span class="va">v</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">x</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readArr</span><span> </span><span class="va">a</span><span> </span><span class="va">i</span><span>
    </span><span class="va">writeArr</span><span> </span><span class="va">a</span><span> </span><span class="va">i</span><span> </span><span class="ot">(</span><span class="va">f</span><span> </span><span class="va">x</span><span> </span><span class="va">v</span><span class="ot">)</span></code></pre></div>
<p>Let’s reformulate IO in terms of state transformers. It can be thought of as
a state transformer of type <code>ST RealWorld a</code>, where <code>RealWorld</code> is an abstract
type representing the real world. We can make this explicit as a type synonym:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">IO</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">ST</span><span> </span><span class="dt">RealWorld</span><span> </span><span class="va">a</span></code></pre></div>
<p>We also have a few functions that are specific to IO but not other ST
computations, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">putChar</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Char</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">IO</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">getChar</span><span> </span><span class="ot">::</span><span> </span><span class="dt">IO</span><span> </span><span class="dt">Char</span></code></pre></div>
<p>And this is enough to build e.g. <code>putString</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">putString</span><span> </span><span class="va">cs</span><span> </span><span class="ot">=</span><span> </span><span class="va">seqST</span><span> </span><span class="ot">(</span><span class="va">map</span><span> </span><span class="va">putChar</span><span> </span><span class="va">cs</span><span class="ot">)</span></code></pre></div>
<p>However, we can take it further and define both <code>putChar</code> and <code>getChar</code> in
terms of <code>ccall</code>, which is a language construct that allows the programmer to
call any C procedure (with certain restrictions placed on its use):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">putChar</span><span> </span><span class="va">c</span><span> </span><span class="ot">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="kw">ccall</span><span> </span><span class="va">putChar</span><span> </span><span class="va">c</span><span>
    </span><span class="va">return</span><span> </span><span class="ot">(</span><span class="ot">)</span><span>
</span><span class="va">getChar</span><span> </span><span class="ot">=</span><span> </span><span class="kw">ccall</span><span> </span><span class="va">getChar</span></code></pre></div>
<p>Because <code>IO</code> is not polymorphic in its state, it can’t be used with <code>runST</code>.
This is the behaviour we want, and we need to define a special function to
execute <code>IO</code> actions. We can call this <code>mainIO</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">mainIO</span><span> </span><span class="ot">::</span><span> </span><span class="dt">IO</span><span> </span><span class="ot">(</span><span class="ot">)</span></code></pre></div>
<p>and have it play a role similar to <code>main()</code> in C. In fact, IO in GHC is
implemented in Haskell in precisely this manner.</p>
<p>There follows a section with formal semantics which formalises what we’ve seen
already and outlines a proof of safety. I won’t go into more detail than that.</p>
<p>Now we come to the implementation. It is crucial that updates happen in-place,
and we justify this by arguing that each combinator uses the state in a single
threaded way and is strict in it, so there should be no unevaluated reads
depending on some state. We achieve data hiding through the monadic interface.</p>
<p>A useful first approximation is the definition of the well-known <code>State</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">=</span><span> </span><span class="dt">State</span><span> </span><span class="va">s</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">a</span><span class="ot">,</span><span> </span><span class="dt">State</span><span> </span><span class="va">s</span><span class="ot">)</span><span>

</span><span class="kw">instance</span><span> </span><span class="dt">Monad</span><span> </span><span class="ot">(</span><span class="dt">ST</span><span> </span><span class="va">s</span><span class="ot">)</span><span> </span><span class="kw">where</span><span>

</span><span class="va">return</span><span>  </span><span class="va">x</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="va">x</span><span class="ot">,</span><span> </span><span class="va">s</span><span class="ot">)</span><span>
</span><span class="va">m</span><span> </span><span class="ot">(</span><span class="op">&gt;&gt;=</span><span class="ot">)</span><span> </span><span class="va">k</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="va">k</span><span> </span><span class="va">x</span><span> </span><span class="va">s'</span><span> </span><span class="kw">where</span><span> </span><span class="ot">(</span><span class="va">x</span><span class="ot">,</span><span> </span><span class="va">s'</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">m</span><span> </span><span class="va">s</span><span>

</span><span class="va">fixST</span><span> </span><span class="va">k</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="ot">(</span><span class="va">r</span><span class="ot">,</span><span> </span><span class="va">s'</span><span class="ot">)</span><span> </span><span class="kw">where</span><span> </span><span class="ot">(</span><span class="va">r</span><span class="ot">,</span><span> </span><span class="va">s'</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">k</span><span> </span><span class="va">r</span><span> </span><span class="va">s</span><span>
</span><span class="va">runST</span><span> </span><span class="va">m</span><span> </span><span class="ot">=</span><span> </span><span class="va">r</span><span> </span><span class="kw">where</span><span> </span><span class="ot">(</span><span class="va">r</span><span class="ot">,</span><span> </span><span class="va">s</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">m</span><span> </span><span class="va">currentState</span></code></pre></div>
<p>The interesting thing to note here is the definition of <code>fixST</code>, which works
regardless of the state passed to it and so is passed a placeholder value.
Strictness is enforced by the use of unboxed values.</p>
<p>This implementation lends itself to inlining and optimisation, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span><span>
    </span><span class="va">v1</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">m1</span><span>
    </span><span class="va">v2</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">m2</span><span>
    </span><span class="va">return</span><span> </span><span class="va">e</span></code></pre></div>
<p>can be inlined to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">\</span><span class="va">s</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">let</span><span> </span><span class="ot">(</span><span class="va">v1</span><span class="ot">,</span><span> </span><span class="va">s1</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">m1</span><span> </span><span class="va">s</span><span>
          </span><span class="ot">(</span><span class="va">v2</span><span class="ot">,</span><span> </span><span class="va">s2</span><span class="ot">)</span><span> </span><span class="ot">=</span><span> </span><span class="va">m2</span><span> </span><span class="va">s1</span><span>
      </span><span class="kw">in</span><span> </span><span class="ot">(</span><span class="va">e</span><span class="ot">,</span><span> </span><span class="va">s3</span><span class="ot">)</span></code></pre></div>
<p>and further optimised to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">\</span><span class="va">s</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">case</span><span> </span><span class="va">m1</span><span> </span><span class="va">s</span><span> </span><span class="kw">of</span><span>
        </span><span class="ot">(</span><span class="va">v1</span><span class="ot">,</span><span> </span><span class="va">s1</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="kw">case</span><span> </span><span class="va">m2</span><span> </span><span class="va">s1</span><span> </span><span class="kw">of</span><span>
                      </span><span class="ot">(</span><span class="va">v2</span><span class="ot">,</span><span> </span><span class="va">s2</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">e</span><span class="ot">,</span><span> </span><span class="va">s2</span><span class="ot">)</span></code></pre></div>
<p>What is the role of the explicit state? It preserves the ordering of operations
because each step relies on the state output by the previous step, and allows
us to communicate strictness when defined like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span><span> </span><span class="dt">State</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="dt">MkState</span><span> </span><span class="ot">(</span><span class="dt">State#</span><span> </span><span class="va">s</span><span class="ot">)</span></code></pre></div>
<p>where <code>State# s</code> is the primitive type of states. <code>newVar</code> can be defined as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">newVar</span><span> </span><span class="va">init</span><span> </span><span class="ot">(</span><span class="dt">MkState</span><span> </span><span class="va">s#</span><span class="ot">)</span><span>
  </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">newVar#</span><span> </span><span class="va">init</span><span> </span><span class="va">s#</span><span> </span><span class="kw">of</span><span>
        </span><span class="ot">(</span><span class="va">v</span><span class="ot">,</span><span> </span><span class="va">t#</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="ot">(</span><span class="va">v</span><span class="ot">,</span><span> </span><span class="dt">MkState</span><span> </span><span class="va">t#</span><span class="ot">)</span></code></pre></div>
<p>where <code>State# s</code> is a ‘token’ that is very important although its precise value
does not matter.</p>
<p>Arrays can be similarly implemented, except for <code>freezeArray</code> which can be
optimised for the scenario where no further mutations are performed.</p>
<p><code>IO</code> is special because the final state of the thread will be demanded: the
whole purpose of using <code>IO</code> is to perform some effect on the outside world.
Noting this, <code>(&gt;&gt;=)</code> can be implemented by</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">m</span><span> </span><span class="ot">(</span><span class="op">&gt;&gt;=</span><span class="ot">)</span><span> </span><span class="va">k</span><span> </span><span class="va">s</span><span> </span><span class="ot">=</span><span> </span><span class="kw">case</span><span> </span><span class="va">m</span><span> </span><span class="va">s</span><span> </span><span class="kw">of</span><span>
                </span><span class="ot">(</span><span class="va">r</span><span class="ot">,</span><span> </span><span class="va">s'</span><span class="ot">)</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="va">k</span><span> </span><span class="va">r</span><span> </span><span class="va">s'</span></code></pre></div>
<p>replacing the earlier <code>let</code> with a <code>case</code> which is more strict.</p>
<p>We can introduce some more combinators, such as a reference equality check:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">eqMutVar</span><span> </span><span class="ot">::</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">MutVar</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bool</span><span>
</span><span class="va">eqMutArr</span><span> </span><span class="ot">::</span><span> </span><span class="dt">Ix</span><span> </span><span class="va">i</span><span> </span><span class="ot">=&gt;</span><span> </span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">MutArr</span><span> </span><span class="va">s</span><span> </span><span class="va">i</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">Bool</span></code></pre></div>
<p>and we can even reintroduce laziness:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">interleaveST</span><span> </span><span class="ot">::</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">ST</span><span> </span><span class="va">s</span><span> </span><span class="va">a</span></code></pre></div>
<p>by duplicating the state. This allows us to write programs like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="va">readFile</span><span> </span><span class="ot">::</span><span> </span><span class="dt">String</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">IO</span><span> </span><span class="ot">[</span><span class="dt">Char</span><span class="ot">]</span><span>
</span><span class="va">readFile</span><span> </span><span class="va">filename</span><span> </span><span class="ot">=</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">f</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">openFile</span><span> </span><span class="va">filename</span><span>
    </span><span class="va">readCts</span><span> </span><span class="va">f</span><span>

</span><span class="va">readCts</span><span> </span><span class="ot">::</span><span> </span><span class="dt">FileDescriptor</span><span> </span><span class="ot">-&gt;</span><span> </span><span class="dt">IO</span><span> </span><span class="ot">[</span><span class="dt">Char</span><span class="ot">]</span><span>
</span><span class="va">readCts</span><span> </span><span class="va">f</span><span> </span><span class="ot">=</span><span> </span><span class="va">interleaveST</span><span> </span><span class="op">$</span><span> </span><span class="kw">do</span><span>
    </span><span class="va">c</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readCh</span><span> </span><span class="va">f</span><span>
    </span><span class="kw">if</span><span> </span><span class="va">c</span><span> </span><span class="op">==</span><span> </span><span class="va">eofChar</span><span>
        </span><span class="kw">then</span><span> </span><span class="va">return</span><span> </span><span class="ot">[</span><span class="ot">]</span><span>
        </span><span class="kw">else</span><span> </span><span class="kw">do</span><span>
            </span><span class="va">cs</span><span> </span><span class="ot">&lt;-</span><span> </span><span class="va">readCts</span><span> </span><span class="va">f</span><span>
            </span><span class="va">return</span><span> </span><span class="ot">(</span><span class="va">c</span><span class="ot">:</span><span class="va">cs</span><span class="ot">)</span></code></pre></div>
<p>but also opens the door to incorrect programs because it is the programmer’s
obligation to ensure that side effects in both branches of the fork are
independent.</p>

        </div>
        <div id="footer">
            <div class="rc-webring">
                <a href="https://webring.recurse.com"><img src="https://webring.recurse.com/icon.svg" /> RC Webring</a>
            </div>
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
        <script data-goatcounter="//vaibhavsagar.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <script type="text/javascript" id="MathJax-script" async src="//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
        </script>
        <script>
        window.MathJax = {
            loader: {load: ['[tex]/color', '[tex]/cancel', '[tex]/textmacros']},
            tex: {packages: {'[+]': ['color', 'cancel', 'textmacros']}}
        };
        </script>
    </body>
</html>
