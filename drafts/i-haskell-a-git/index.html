<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Vaibhav Sagar - I Haskell a Git</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../about/">About</a>
                <a href="../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>I Haskell a Git</h1>

            <div class="info">
    Posted on  5 August 2017
    
</div>
<div class="info">
    
        Tags: <a href="../../blog/tags/programming/">programming</a>, <a href="../../blog/tags/haskell/">haskell</a>, <a href="../../blog/tags/git/">git</a>
    
</div>

<p>I struggled with Git for a long time, and every time I thought I had finally made sense of it, I would accidentally delete a repository or mess up a branch, causing me to question my grasp of what I was doing. I found it very difficult to form a mental model of the tool from the proliferation of seemingly endless command line flags that I had to use to achieve anything meaningful, and the cryptic errors that would inevitably result.</p>
<p>When I finally thought I understood what was going on, I offered to give a talk on it to the local functional group, because Git is functional, right? The co-organisers explained that it wouldn‚Äôt be an interesting or useful talk, but a talk on implementing Git in Haskell would be very welcome.</p>
<p>That was enough motivation to start working on a <a href="https://github.com/vaibhavsagar/duffer">Git library</a>, and it turns out that understanding Git from the inside out is far, far easier than whatever I was trying to do earlier. This blog post is my attempt to share that comfort and understanding with you.</p>
<p>I‚Äôve chosen to write this as an IHaskell notebook that is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/git-from-scratch">here</a>, and I‚Äôve included a <code>default.nix</code> to make things easier if you have Nix installed. You should be able to run</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nix-build</span> .
$ <span class="ex">result/bin/ihaskell-notebook</span></code></pre></div>
<p>to open a Jupyter notebook environment with all the dependencies you‚Äôll need to follow along.</p>
<p>GHCi has a handy Vim-inspired feature where a command prefixed with <code>:!</code> is run in the shell, and IHaskell supports this as well, so I‚Äôll be using that heavily to keep everything self-contained.</p>
<p>Let‚Äôs start by picking a Git repository. I picked Ethan Schoonover‚Äôs <a href="https://github.com/altercation/solarized/">solarized</a> because it‚Äôs large, well-known, and was last updated in 2011, so I‚Äôm confident that the hashes here won‚Äôt go out of date.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="fu">:!</span><span class="kw">if</span> [ <span class="fu">-</span>d solarized<span class="fu">/</span> ]; <span class="kw">then</span> rm <span class="fu">-</span>rf solarized; fi
<span class="fu">:!</span>git clone https<span class="fu">://</span>github<span class="fu">.</span>com<span class="fu">/</span>altercation<span class="fu">/</span>solarized
<span class="fu">:!</span>cd solarized
<span class="fu">:!</span>git show <span class="co">--format=raw -s</span></code></pre></div>
<pre><code>Cloning into 'solarized'...
done.



commit e40cd4130e2a82f9b03ada1ca378b7701b1a9110
tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

    add tmux by @seebi!</code></pre>
<p><code>git show</code> displays the latest commit on the current branch, <code>--format=raw</code> shows it in raw format, and the <code>-s</code> flag suppresses the diff output, which (as we‚Äôll see later) isn‚Äôt part of the commit.</p>
<p>The first thing we have to address is the fact that Git has two storage formats: loose objects and packfiles. Loose objects are used below a certain size threshold as an on-disk format, and packfiles are used to transfer files over the network because transferring one large file has less overhead than transferring lots of small files. Loose objects are easier to work with, so I‚Äôm going to convert the packfiles into loose objects.</p>
<p>If you‚Äôd like to learn more about packfiles, my favourite resource is Aditya Mukerjee‚Äôs <a href="https://codewords.recurse.com/issues/three/unpacking-git-packfiles">Unpacking Git packfiles</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>mv <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>pack<span class="fu">/*</span> <span class="fu">.</span>
<span class="fu">:!</span>cat <span class="fu">*.</span>pack <span class="fu">|</span> git unpack<span class="fu">-</span>objects
<span class="fu">:!</span>rm <span class="fu">-</span>rf pack<span class="fu">-*</span></code></pre></div>
<p>Okay, the packfiles are gone and there are only loose objects now.</p>
<p><code>git show</code> is an example of a ‚Äòporcelain‚Äô command for users to interact with, as opposed to a ‚Äòplumbing‚Äô command that is more low-level and meant for Git itself to use under the hood. The latest commit on the current branch is known as the <code>HEAD</code> commit, and we should be able to use <code>git cat-file -p</code> to get essentially the same output as before (the <code>-p</code> flag means ‚Äòpretty-print‚Äô).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p <span class="dt">HEAD</span></code></pre></div>
<pre><code>tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p><code>HEAD</code> is in fact a file that lives at <code>.git/HEAD</code>. Let‚Äôs view its contents.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span><span class="dt">HEAD</span></code></pre></div>
<pre><code>ref: refs/heads/master</code></pre>
<p>This is essentially a symlink in text. <code>refs/heads/master</code> refers to <code>.git/refs/heads/master</code>. What are its contents?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span>refs<span class="fu">/</span>heads<span class="fu">/</span>master</code></pre></div>
<pre><code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre>
<p>Okay, no more pointers! This is a SHA1 hash representing the commit we want. One last <code>git cat-file -p</code>‚Ä¶</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre></div>
<pre><code>tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>As expected, we get the same output as before. On to something different: <code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code> is a reference to an object stored at <code>.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110</code>. The first two characters of the hash are the directory name and the 38 remaining characters are the file name underneath that directory. It‚Äôs worth pointing out that all objects are stored in this format, and there‚Äôs no separation between object types or anything like that.</p>
<p>This unusual directory structure was chosen as a tradeoff between the number of directories under <code>.git/objects</code> and the number of files under each of those directories. One approach might have been to use 40-character file names and put all objects under <code>.git/objects</code>. However, some filesystems have operations that are <code>O(n)</code> in the number of files in a directory, and working with large repositories would get very slow in this case. Another approach would have been to use the first character of the hash as the directory name, which would lead to at most 16 directories under <code>.git/objects</code>. Git settled on the first two characters, which gives us at most 256 directories.</p>
<p>Let‚Äôs confirm that the file does exist, and then look at its contents.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>ls <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110
<span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre></div>
<pre><code>.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110



x¬ï¬émj1D√ª√õ¬ßP√ê√¢/√ôZ(%√¥¬π¬Ä¬¥R√©B¬ù¬ÆS¬í√õ√ó¬ê^¬†¬ø√É¬õY√∑√ñ¬∂1√ì√ì√®f`¬´zC√íB)b)¬ò='¬Ø¬ö¬©¬í
R√å√î¬ªw;`I+¬ñ\$¬µ E¬¨S¬ë¬ñ√ô'&amp;fB√á√ó√±¬πw8u√ª¬ô√±√û¬π√â¬ó√Å√´v¬ñ√Ωv¬ú√ì¬ì√ä¬æ¬¨{{¬É¬ê√™&lt;√ΩB√∞√¨¬´√∑n√í√πt√ò√ø1√§?¬ácU√≠z¬π√É√±√õL¬∂¬É√ª√àO¬Å</code></pre>
<p>Git compresses these files with zlib before storing them, and we‚Äôll need to handle this. Fortunately there‚Äôs a tool called <code>zlib-flate</code> (part of the <code>qpdf</code> package) that we can use.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>zlib<span class="fu">-</span>flate <span class="fu">-</span>uncompress <span class="fu">&lt;</span> <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre></div>
<pre><code>commit 248 tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>This is identical to the output of <code>git cat-file -p</code>, except for the <code>commit 248</code> at the beginning. That‚Äôs a header that Git uses to tell different types of objects apart, and <code>248</code> is the content length of this particular commit. There‚Äôs also a null byte after the content length that the shell is not displaying here, and this will become important when we write code to handle the header in a moment.</p>
<p>I‚Äôm done playing with the shell for now, and I want to write some code. The first thing I‚Äôd like to do is import some libraries and define helper functions for compresssion and decompression. Haskell‚Äôs <code>zlib</code> library works with lazy bytestrings but I‚Äôd rather use strict bytestrings in the rest of my code because Attoparsec seems to prefer it, so I‚Äôll define <code>compress</code> and <code>decompress</code> accordingly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Codec.Compression.Zlib</span> <span class="kw">as</span> <span class="dt">Z</span> (compress, decompress)
<span class="kw">import           </span><span class="dt">Data.ByteString.Lazy</span>        (fromStrict, toStrict)
<span class="kw">import           </span><span class="dt">Data.ByteString</span>             (<span class="dt">ByteString</span>)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span>        <span class="kw">as</span> <span class="dt">B</span>

compress,<span class="ot"> decompress ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
compress   <span class="fu">=</span> toStrict <span class="fu">.</span> Z.compress   <span class="fu">.</span> fromStrict
decompress <span class="fu">=</span> toStrict <span class="fu">.</span> Z.decompress <span class="fu">.</span> fromStrict</code></pre></div>
<p>Now to recreate the <code>zlib-flate</code> output from earlier, and demonstrate the presence of that null byte in the header:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">commit <span class="ot">&lt;-</span> B.readFile <span class="st">&quot;.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110&quot;</span>
print <span class="fu">$</span> decompress commit</code></pre></div>
<pre><code>&quot;commit 248\NULtree ecd0e58d6832566540a30dfd4878db518d5451d0\nparent ab3c5646b41de1b6d95782371289db585ba8aa85\nauthor Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700\ncommitter Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700\n\nadd tmux by @seebi!\n&quot;</code></pre>
<p>Next, I want to make sense of this content, and by ‚Äòmake sense of‚Äô I mean ‚Äòwrite a parser for‚Äô, because a parser is a function that turns a sequence of bytes (or more generally tokens) into values that I can work with. I also want to define serialisers (or unparsers, as I like to think of them) that take those values and turn them back into the sequence of bytes we started with.</p>
<p>Haskell has a couple of great options for this, and I‚Äôve decided to go with <code>attoparsec</code>. It does the right thing and accounts for a parsing failure by default, but I‚Äôm pretty confident that my parsers won‚Äôt fail, so I‚Äôll define a helper function that gets rid of that behaviour.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Data.Attoparsec.ByteString</span> (<span class="dt">Parser</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Attoparsec.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">AC</span>

<span class="ot">parsed ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a
parsed parser <span class="fu">=</span> either error id <span class="fu">.</span> AC.parseOnly parser</code></pre></div>
<p>Let‚Äôs write our first parser! We‚Äôll start with a simple one for the header. We want some sequence of characters, a space, a number, and a null byte, and parser combinators make implementing this straightforward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseHeader ::</span> <span class="dt">Parser</span> (<span class="dt">ByteString</span>, <span class="dt">Int</span>)
parseHeader <span class="fu">=</span> <span class="kw">do</span>
    objectType <span class="ot">&lt;-</span> AC.takeTill AC.isSpace
    AC.space
    len <span class="ot">&lt;-</span> AC.decimal
    AC.char <span class="ch">'\NUL'</span>
    return (objectType, len)

commit <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110&quot;</span>

parsed parseHeader commit</code></pre></div>
<pre><code>(&quot;commit&quot;,248)</code></pre>
<p>The next parser I want is one for references. The correct way to do this is to look for 40 characters that are in the range 0-9 or a-f, but I‚Äôm lazy and I‚Äôm going to just grab 40 characters instead. Rabbit hole: write a parser that only parses valid SHA1 hashes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Ref</span> <span class="fu">=</span> <span class="dt">ByteString</span>

<span class="ot">parseHexRef ::</span> <span class="dt">Parser</span> <span class="dt">Ref</span>
parseHexRef <span class="fu">=</span> AC.take <span class="dv">40</span></code></pre></div>
<p>We now have all the smaller parsers we‚Äôll need to plug together in order to parse a commit. We want to parse the <code>tree</code>, any number of <code>parent</code>s, an <code>author</code>, a <code>committer</code>, and a message. Why any number of parents? The initial commit of a repository won‚Äôt have any parents, and merge commits will have at least two, although there can be more (this is known as an <a href="https://www.destroyallsoftware.com/blog/2017/the-biggest-and-weirdest-commits-in-linux-kernel-git-history">octopus merge</a>).</p>
<p>The author and committer lines consist of a user‚Äôs name, their email, the unix timestamp, and the timezone. A better parser for this would validate each of those components, but to demonstrate I‚Äôm just going to grab the whole line. Rabbit hole: write the better person+time parser.</p>
<p>One thing I really like about parser combinators is that I can write a parser whose form imitates the content I‚Äôm trying to parse. This is purely a cute stylistic quirk, but I enjoy doing it anyway.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Commit</span> <span class="fu">=</span> <span class="dt">Commit</span>
    {<span class="ot"> commitTree      ::</span> <span class="dt">Ref</span>
    ,<span class="ot"> commitParents   ::</span> [<span class="dt">Ref</span>]
    ,<span class="ot"> commitAuthor    ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> commitCommitter ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> commitMessage   ::</span> <span class="dt">ByteString</span>
    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

parseCommit <span class="fu">=</span> <span class="kw">do</span>
    cTree      <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;tree&quot;</span>      <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                   <span class="fu">&lt;*</span> AC.endOfLine
    cParents   <span class="ot">&lt;-</span> AC.many' (AC.string <span class="st">&quot;parent&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                   <span class="fu">&lt;*</span> AC.endOfLine)
    cAuthor    <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;author&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>) <span class="fu">&lt;*</span> AC.endOfLine
    cCommitter <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;committer&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>) <span class="fu">&lt;*</span> AC.endOfLine
    AC.endOfLine
    cMessage   <span class="ot">&lt;-</span> AC.takeByteString
    return <span class="fu">$</span> <span class="dt">Commit</span> cTree cParents cAuthor cCommitter cMessage

parsed (parseHeader <span class="fu">*&gt;</span> parseCommit) commit</code></pre></div>
<pre><code>Commit {commitTree = &quot;ecd0e58d6832566540a30dfd4878db518d5451d0&quot;, commitParents = [&quot;ab3c5646b41de1b6d95782371289db585ba8aa85&quot;], commitAuthor = &quot;Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700&quot;, commitCommitter = &quot;Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700&quot;, commitMessage = &quot;add tmux by @seebi!\n&quot;}</code></pre>
<p>Now to write our first serialiser that takes values of the Commit type and turns them back into bytestrings. Again, with some formatting liberties I can make this look a lot like the content I want to output. I can quickly check the <a href="http://teh.id.au/posts/2017/06/07/round-trip-property/">roundtrip property</a> to see that both my parser and serialiser work properly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span> ((&lt;&gt;), mappend, mconcat)
<span class="kw">import </span><span class="dt">Data.Byteable</span>

<span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Commit</span> <span class="kw">where</span>
    toBytes (<span class="dt">Commit</span> cTree cParents cAuthor cCommitter cMessage) <span class="fu">=</span> mconcat
        [                        <span class="st">&quot;tree &quot;</span>      <span class="fu">&lt;&gt;</span> cTree      <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        , mconcat (map (\cRef <span class="ot">-&gt;</span> <span class="st">&quot;parent &quot;</span>    <span class="fu">&lt;&gt;</span> cRef       <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>) cParents)
        ,                        <span class="st">&quot;author &quot;</span>    <span class="fu">&lt;&gt;</span> cAuthor    <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        ,                        <span class="st">&quot;committer &quot;</span> <span class="fu">&lt;&gt;</span> cCommitter <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        ,                                                      <span class="st">&quot;\n&quot;</span>
        ,                                        cMessage
        ]

parsedCommit <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseCommit) commit
(parsed parseCommit <span class="fu">.</span> toBytes <span class="fu">$</span> parsedCommit) <span class="fu">==</span> parsedCommit</code></pre></div>
<pre><code>True</code></pre>
<p>Let‚Äôs backtrack and also define a serialiser for our headers.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.ByteString.UTF8</span> (fromString, toString)

<span class="ot">withHeader ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
withHeader oType content <span class="fu">=</span> mconcat [oType, <span class="st">&quot; &quot;</span>, fromString <span class="fu">.</span> show <span class="fu">$</span> B.length content, <span class="st">&quot;\NUL&quot;</span>, content]

withHeader <span class="st">&quot;commit&quot;</span> (toBytes parsedCommit)</code></pre></div>
<pre><code>commit 248 tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>Great, it looks like that does the right thing. We‚Äôll test it more thoroughly later.</p>
<p>So far I‚Äôve avoided the question of where the hashes come from. Git is a content-addressable store (CAS) and the content of our Git objects uniquely determines their hash. This is very much like a hash table, and that‚Äôs a useful way to think about Git: a hashtable on the filesystem.</p>
<p>More specifically, the SHA1 hash of a Git object before compression is used as the reference. Let me demonstrate.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Digest.Pure.SHA</span>

<span class="ot">hash ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Ref</span>
hash <span class="fu">=</span> fromString <span class="fu">.</span> showDigest <span class="fu">.</span> sha1 <span class="fu">.</span> fromStrict

hash (withHeader <span class="st">&quot;commit&quot;</span> (toBytes parsedCommit))</code></pre></div>
<pre><code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre>
<p>This is the same hash as the one we‚Äôve been using to get at the commit so far, which is consistent with my explanation.</p>
<p>Now that we‚Äôre done with commits, let‚Äôs look at trees. A tree is what Git calls a directory listing. I think the tree reference <code>ecd0e58d6832566540a30dfd4878db518d5451d0</code> in the above commit is a good one to start with.</p>
<p>A tree object consists of some number of tree entries, and each tree entry represents a directory/file, with a reference to another Git object that stores the actual content of the directory/file.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p ecd0e58d6832566540a30dfd4878db518d5451d0</code></pre></div>
<pre><code>100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	.gitmodules
100644 blob ec00a76061539cf774614788270214499696f871	CHANGELOG.mkd
100644 blob f95aaf80007d225f00d3109987ee42ef2c2e0c0a	DEVELOPERS.mkd
100644 blob ee08d7e44f15108ef5359550399dad55955b56ca	LICENSE
100644 blob d18ee9450251ea1b9a02ebd4d6fce022df9eb5e4	README.md
040000 tree 1981c76881c6a14e14d067a44247acd1bf6bbc3a	adobe-swatches-solarized
040000 tree 825c732bdd3a62aeb543ca89026a26a2ee0fba26	apple-colorpalette-solarized
040000 tree 7bab2828df5de23262a821cc48fe0ccf8bd2a9ae	emacs-colors-solarized
040000 tree f5fe8c3e20b2577223f617683a52eac31c5c9f30	files
040000 tree 5b60111510dbb3d8560cf58a36a20a99fc175658	gedit
040000 tree 60c9df3d6e1994b76d72c061a02639af3d925655	gimp-palette-solarized
040000 tree 979cf43752e4d698c7b5b47cff665142a274c133	img
040000 tree 3ff6d431303b66cc50e45b6fabd72302f210aebc	intellij-colors-solarized
040000 tree 8f387a531ad08f146c86e4b6007b898064ad4d7f	iterm2-colors-solarized
040000 tree 1e37592e62c85909be4c5e5eb774f177766e8422	mutt-colors-solarized
040000 tree 8f321f917040d903f701a2b33aeee26aed2ee544	netbeans-colors-solarized
040000 tree 0d408465820822f6a2afccf43e9627375fedc278	osx-terminal.app-colors-solarized
040000 tree 63dfa6c40d214f8e0f76d39f7a2283e053940a19	putty-colors-solarized
040000 tree 453921a267d3eb855e40c7de73aee46088563f3e	qtcreator
040000 tree 5dd6832a324187f8f521bef928891fb87cf845f6	seestyle-colors-solarized
040000 tree 3c15973ed107e7b37d1c4885f82984658ecbdf6a	textmate-colors-solarized
040000 tree 4db152b36a47e31a872e778c02161f537888e44b	textwrangler-bbedit-colors-solarized
040000 tree 09b5f2f69e1596c6ff66fb187ea6bdc385845152	tmux
040000 tree 635ebbb919fcbbaf6fe958998553bf3f5fe09210	utils
040000 tree b87a2100b0a79424cd4b2a4e4ef03274b130a206	vim-colors-solarized
040000 tree 8dea7190b79c05404aa6a1f0d67c5c6671d66fe1	visualstudio-colors-solarized
040000 tree 0a531826e913a4b11823ee1be6e1b367f826006f	xchat
040000 tree 2870bdf394a6b6b3bd10c263ffe9396a0d3d3366	xfce4-terminal
040000 tree 5d1a212e2fd9cdc2b678e3be56cf776b2f16cfe2	xresources</code></pre>
<p>The number at the beginning of each entry represents the entry permissions, and is a subset of Unix file permissions. <code>100644</code> corresponds to a blob, which is the Git object corresponding to a file, and <code>040000</code> corresponds to a tree. Other numbers exist but are uncommon. The rest of the tree entry is the entry reference and the entry name.</p>
<p>As before, we should be able to decompress the file and get essentially the same output as before, right?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tree <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/ec/d0e58d6832566540a30dfd4878db518d5451d0&quot;</span>
print tree</code></pre></div>
<pre><code>&quot;tree 1282\NUL100644 .gitmodules\NUL\230\157\226\155\178\209\214CK\139)\174wZ\216\194\228\140S\145\&amp;100644 CHANGELOG.mkd\NUL\236\NUL\167`aS\156\247taG\136'\STX\DC4I\150\150\248q100644 DEVELOPERS.mkd\NUL\249Z\175\128\NUL}\&quot;_\NUL\211\DLE\153\135\238B\239,.\f\n100644 LICENSE\NUL\238\b\215\228O\NAK\DLE\142\245\&amp;5\149P9\157\173U\149[V\202\&amp;100644 README.md\NUL\209\142\233E\STXQ\234\ESC\154\STX\235\212\214\252\224\&quot;\223\158\181\228\&amp;40000 adobe-swatches-solarized\NUL\EM\129\199h\129\198\161N\DC4\208g\164BG\172\209\191k\188:40000 apple-colorpalette-solarized\NUL\130\\s+\221:b\174\181C\202\137\STXj&amp;\162\238\SI\186&amp;40000 emacs-colors-solarized\NUL{\171((\223]\226\&amp;2b\168!\204H\254\f\207\139\210\169\174\&amp;40000 files\NUL\245\254\140&gt; \178Wr#\246\ETBh:R\234\195\FS\\\159\&amp;040000 gedit\NUL[`\DC1\NAK\DLE\219\179\216V\f\245\138\&amp;6\162\n\153\252\ETBVX40000 gimp-palette-solarized\NUL`\201\223=n\EM\148\183mr\192a\160&amp;9\175=\146VU40000 img\NUL\151\156\244\&amp;7R\228\214\152\199\181\180|\255fQB\162t\193\&amp;340000 intellij-colors-solarized\NUL?\246\212\&amp;10;f\204P\228[o\171\215#\STX\242\DLE\174\188\&amp;40000 iterm2-colors-solarized\NUL\143\&amp;8zS\SUB\208\143\DC4l\134\228\182\NUL{\137\128d\173M\DEL40000 mutt-colors-solarized\NUL\RS7Y.b\200Y\t\190L^^\183t\241wvn\132\&quot;40000 netbeans-colors-solarized\NUL\143\&amp;2\US\145p@\217\ETX\247\SOH\162\179:\238\226j\237.\229D40000 osx-terminal.app-colors-solarized\NUL\r@\132e\130\b\&quot;\246\162\175\204\244&gt;\150'7_\237\194x40000 putty-colors-solarized\NULc\223\166\196\r!O\142\SIv\211\159z\&quot;\131\224S\148\n\EM40000 qtcreator\NULE9!\162g\211\235\133^@\199\222s\174\228`\136V?&gt;40000 seestyle-colors-solarized\NUL]\214\131*2A\135\248\245!\190\249(\137\US\184|\248E\246\&amp;40000 textmate-colors-solarized\NUL&lt;\NAK\151&gt;\209\a\231\179}\FSH\133\248)\132e\142\203\223j40000 textwrangler-bbedit-colors-solarized\NULM\177R\179jG\227\SUB\135.w\140\STX\SYN\USSx\136\228K40000 tmux\NUL\t\181\242\246\158\NAK\150\198\255f\251\CAN~\166\189\195\133\132QR40000 utils\NULc^\187\185\EM\252\187\175o\233X\153\133S\191?_\224\146\DLE40000 vim-colors-solarized\NUL\184z!\NUL\176\167\148$\205K*NN\240\&amp;2t\177\&amp;0\162\ACK40000 visualstudio-colors-solarized\NUL\141\234q\144\183\156\ENQ@J\166\161\240\214|\\fq\214o\225\&amp;40000 xchat\NUL\nS\CAN&amp;\233\DC3\164\177\CAN#\238\ESC\230\225\179g\248&amp;\NULo40000 xfce4-terminal\NUL(p\189\243\148\166\182\179\189\DLE\194c\255\233\&amp;9j\r=3f40000 xresources\NUL]\SUB!./\217\205\194\182x\227\190V\207wk/\SYN\207\226&quot;</code></pre>
<p>Although this looks very much like gibberish, it is the same content as above with one big difference: instead of the 40-byte hexadecimal representation of a SHA1 hash, the 20-byte representation is used. The <code>tree &lt;length&gt;</code> header is present, as is the entry permission. Each entry name is followed by a <code>\NUL</code> to facilitate parsing.</p>
<p>We are now able to define a parser for tree objects. Rabbit hole: the tree entries need to be sorted in a certain quirky order, and we would like to disallow duplicates. Use a different data structure and manual <code>Ord</code> definitions to ensure this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.ByteString.Base16</span> (encode)

<span class="ot">parseBinRef ::</span> <span class="dt">Parser</span> <span class="dt">Ref</span>
parseBinRef <span class="fu">=</span> encode <span class="fu">&lt;$&gt;</span> AC.take <span class="dv">20</span>

<span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Tree</span> {<span class="ot"> treeEntries ::</span> [<span class="dt">TreeEntry</span>] } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">TreeEntry</span> <span class="fu">=</span> <span class="dt">TreeEntry</span>
    {<span class="ot"> treeEntryPerms ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> treeEntryName  ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> treeEntryRef   ::</span> <span class="dt">Ref</span>
    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">parseTreeEntry ::</span> <span class="dt">Parser</span> <span class="dt">TreeEntry</span>
parseTreeEntry <span class="fu">=</span> <span class="kw">do</span>
    perms <span class="ot">&lt;-</span> fromString <span class="fu">&lt;$&gt;</span> AC.many1' AC.digit
    AC.space
    name  <span class="ot">&lt;-</span> AC.takeWhile (<span class="fu">/=</span><span class="ch">'\NUL'</span>)
    AC.char <span class="ch">'\NUL'</span>
    ref   <span class="ot">&lt;-</span> parseBinRef
    return <span class="fu">$</span> <span class="dt">TreeEntry</span> perms name ref

<span class="ot">parseTree ::</span> <span class="dt">Parser</span> <span class="dt">Tree</span>
parseTree <span class="fu">=</span> <span class="dt">Tree</span> <span class="fu">&lt;$&gt;</span> AC.many' parseTreeEntry

parsedTree <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseTree) tree
parsedTree</code></pre></div>
<pre><code>Tree {treeEntries = [TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;.gitmodules&quot;, treeEntryRef = &quot;e69de29bb2d1d6434b8b29ae775ad8c2e48c5391&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;CHANGELOG.mkd&quot;, treeEntryRef = &quot;ec00a76061539cf774614788270214499696f871&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;DEVELOPERS.mkd&quot;, treeEntryRef = &quot;f95aaf80007d225f00d3109987ee42ef2c2e0c0a&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;LICENSE&quot;, treeEntryRef = &quot;ee08d7e44f15108ef5359550399dad55955b56ca&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;README.md&quot;, treeEntryRef = &quot;d18ee9450251ea1b9a02ebd4d6fce022df9eb5e4&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;adobe-swatches-solarized&quot;, treeEntryRef = &quot;1981c76881c6a14e14d067a44247acd1bf6bbc3a&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;apple-colorpalette-solarized&quot;, treeEntryRef = &quot;825c732bdd3a62aeb543ca89026a26a2ee0fba26&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;emacs-colors-solarized&quot;, treeEntryRef = &quot;7bab2828df5de23262a821cc48fe0ccf8bd2a9ae&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;files&quot;, treeEntryRef = &quot;f5fe8c3e20b2577223f617683a52eac31c5c9f30&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;gedit&quot;, treeEntryRef = &quot;5b60111510dbb3d8560cf58a36a20a99fc175658&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;gimp-palette-solarized&quot;, treeEntryRef = &quot;60c9df3d6e1994b76d72c061a02639af3d925655&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;img&quot;, treeEntryRef = &quot;979cf43752e4d698c7b5b47cff665142a274c133&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;intellij-colors-solarized&quot;, treeEntryRef = &quot;3ff6d431303b66cc50e45b6fabd72302f210aebc&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;iterm2-colors-solarized&quot;, treeEntryRef = &quot;8f387a531ad08f146c86e4b6007b898064ad4d7f&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;mutt-colors-solarized&quot;, treeEntryRef = &quot;1e37592e62c85909be4c5e5eb774f177766e8422&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;netbeans-colors-solarized&quot;, treeEntryRef = &quot;8f321f917040d903f701a2b33aeee26aed2ee544&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;osx-terminal.app-colors-solarized&quot;, treeEntryRef = &quot;0d408465820822f6a2afccf43e9627375fedc278&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;putty-colors-solarized&quot;, treeEntryRef = &quot;63dfa6c40d214f8e0f76d39f7a2283e053940a19&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;qtcreator&quot;, treeEntryRef = &quot;453921a267d3eb855e40c7de73aee46088563f3e&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;seestyle-colors-solarized&quot;, treeEntryRef = &quot;5dd6832a324187f8f521bef928891fb87cf845f6&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;textmate-colors-solarized&quot;, treeEntryRef = &quot;3c15973ed107e7b37d1c4885f82984658ecbdf6a&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;textwrangler-bbedit-colors-solarized&quot;, treeEntryRef = &quot;4db152b36a47e31a872e778c02161f537888e44b&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;tmux&quot;, treeEntryRef = &quot;09b5f2f69e1596c6ff66fb187ea6bdc385845152&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;utils&quot;, treeEntryRef = &quot;635ebbb919fcbbaf6fe958998553bf3f5fe09210&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;vim-colors-solarized&quot;, treeEntryRef = &quot;b87a2100b0a79424cd4b2a4e4ef03274b130a206&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;visualstudio-colors-solarized&quot;, treeEntryRef = &quot;8dea7190b79c05404aa6a1f0d67c5c6671d66fe1&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xchat&quot;, treeEntryRef = &quot;0a531826e913a4b11823ee1be6e1b367f826006f&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xfce4-terminal&quot;, treeEntryRef = &quot;2870bdf394a6b6b3bd10c263ffe9396a0d3d3366&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xresources&quot;, treeEntryRef = &quot;5d1a212e2fd9cdc2b678e3be56cf776b2f16cfe2&quot;}]}</code></pre>
<p>It‚Äôs similarly straightforward to define a serialiser. All we have to do is serialise the tree entries and concatenate them.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.ByteString.Base16</span> (decode)

<span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">TreeEntry</span> <span class="kw">where</span>
    toBytes (<span class="dt">TreeEntry</span> perms name ref) <span class="fu">=</span> mconcat [perms, <span class="st">&quot; &quot;</span>, name, <span class="st">&quot;\NUL&quot;</span>, fst <span class="fu">$</span> decode ref]

<span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Tree</span> <span class="kw">where</span>
    toBytes (<span class="dt">Tree</span> entries) <span class="fu">=</span> mconcat (map toBytes entries)

(parsed parseTree <span class="fu">.</span> toBytes <span class="fu">$</span> parsedTree) <span class="fu">==</span> parsedTree</code></pre></div>
<pre><code>True</code></pre>
<p>Next we move to blobs. I‚Äôm using the reference associated with <code>CHANGELOG.mkd</code> because <code>.gitmodules</code> is empty, and limiting the output to the first ten lines for now because we‚Äôll see the whole thing later anyway.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p ec00a76061539cf774614788270214499696f871 <span class="fu">|</span> head <span class="fu">-</span>n10</code></pre></div>
<pre><code>Solarized Changelog
===================

## Current release 1.0.0beta2

1.0.0beta2
----------

### Summary</code></pre>
<p>A blob is some bytes with a header.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">BC</span>
blob <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/ec/00a76061539cf774614788270214499696f871&quot;</span>
print <span class="fu">$</span> BC.unlines <span class="fu">.</span> take <span class="dv">10</span> <span class="fu">.</span> BC.lines <span class="fu">$</span> blob</code></pre></div>
<pre><code>&quot;blob 5549\NULSolarized Changelog\n===================\n\n## Current release 1.0.0beta2\n\n1.0.0beta2\n----------\n\n### Summary\n\n&quot;</code></pre>
<p>Parsing these is easy!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Blob</span> <span class="fu">=</span> <span class="dt">Blob</span> {<span class="ot"> blobContent ::</span> <span class="dt">ByteString</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">parseBlob ::</span> <span class="dt">Parser</span> <span class="dt">Blob</span>
parseBlob <span class="fu">=</span> <span class="dt">Blob</span> <span class="fu">&lt;$&gt;</span> AC.takeByteString

parsedBlob <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseBlob) blob
parsedBlob</code></pre></div>
<pre><code>Blob {blobContent = &quot;Solarized Changelog\n===================\n\n## Current release 1.0.0beta2\n\n1.0.0beta2\n----------\n\n### Summary\n\nSwitch to the alternative red hue (final and only hue change), included a whole\nheap of new ports and updates to the existing Vim colorscheme. The list of all \ncurrently included ports, highlighted items are new, updates noted:\n\n#### Editors &amp; IDEs\n\n*   \\[UPDATED\\] **Vim**\n*   \\[NEW\\] ***Emacs***\n*   \\[NEW\\] ***IntelliJ IDEA***\n*   \\[NEW\\] ***NetBeans***\n*   \\[NEW\\] ***SeeStyle theme for Coda &amp; SubEthaEdit***\n*   \\[NEW\\] ***TextMate***\n*   \\[NEW\\] ***Visual Studio***\n\n#### Terminal Emulators\n\n* \\[UPDATED\\] **iTerm2 colorschemes**\n* \\[UPDATED\\] **OS X Terminal.app colors**\n* \\[UPDATED\\] **Xresources colors**\n\n#### Other Applications\n\n* \\[UPDATED\\] **Mutt mail client colorschemes**\n\n#### Palettes\n\n* \\[UPDATED\\] **Adobe Photoshop Swatches**\n* \\[UPDATED\\] **Apple Color Picker Palette**\n* \\[UPDATED\\] **Gimp Palette**\n\n\n### Critical Changes\n\nThese changes may require you to change your configuration.\n\n*   **GLOBAL : IMPROVEMENT : New red accent color value**\n    Modified red from L\\*a\\*b lightness value 45 to 50 to bring it in\n    line with the other accent colors and address bleed into dark background on \n    some displays, as well as reducing shift of red against base03 when viewed \n    with glasses (chromatic aberration). All instances of the colorscheme and \n    palettes updated to new red and avalailable for use/import without further \n    modification. Forks and ports should pull new changes and/or update ported \n    red value accordingly.  The new red:\n\n            red #dc322f\n\n*   **VIM : CHANGE : Default mode now 16 color**\n    Default terminal mode is now ***16 colors***. Most of the users of terminal \n    mode seem comfortabel and capable changing terminal colors. This is the \n    preferred method of implementing Solarized in Terminal mode. If you wish to \n    instead use the degraded 256 color palette, you may do so with the \n    following line in your .vimrc:\n\n            let g:solarized_termcolors=256\n\n    You no longer need to specify \&quot;let g:solarized_termcolors=16\&quot; as it is now \n    the default; leaving it in your .vimrc won't hurt anything, however.\n\n*   **VIM : IMPROVEMENT : New Toggle Background Plugin**\n    Added new Toggle Background plugin. Will load automatically and show up as \n    a menu item in the `Window` menu in gui vim. Automatically maps to\n    `&lt;F5&gt;` if available (won't clobber that mapping if you're using it).\n    Also available as a command `:ToggleBG`.  To manually map to\n    something other than `&lt;F5&gt;`:\n\n    To set your own mapping in your .vimrc file, simply add the following line \n    to support normal, insert and visual mode usage, changing the\n    \&quot;`&lt;F5&gt;`\&quot; value to the key or key combination you wish to use:\n\n        call togglebg#map(\&quot;&lt;F5&gt;\&quot;)\n\n    Note that you'll want to use a single function key or equivalent if you want \n    the plugin to work in all modes (normal, insert, visual).\n\n*   **VIM : IMPROVEMENT : Special &amp; Non-text items now more visible**\n    Special characters such as trailing whitespace, tabs, newlines, when \n    displayed using \&quot;:set list\&quot; can be set to one of three levels depending on \n    your needs.\n\n            let g:solarized_visibility =  \&quot;normal\&quot;|   \&quot;high\&quot; or \&quot;low\&quot;\n\n    I'll be honest: I still prefer low visibility. I like them barely there.  \n    They show up in lines that are highlighted as by the cursor line, which \n    works for me. If you are with me on this, put the following in your .vimrc:\n\n            let g:solarized_visibility =  \&quot;low\&quot;\n\n### Non Critical Changes\n\nThese changes should not impact your usage of the Solarized.\n\n*   **PALETTES : IMPROVEMENT : Colorspace tagged and untagged versions**\n    Changed default OS X color picker palatte swatches to tagged colors (sRGB) \n    and included alternate palette with untagged color swatches for advanced \n    users (v1.0.0beta1 had untagged as default).\n\n*   **VIM : BUGFIX : Better display in Terminal.app, other emulators**\n    Terminal.app and other common terminal emulators that report 8 color mode \n    had display issues due to order of synt highlighting definitions and color \n    values specified. These have been conformed and reordered in such a way \n    that there is a more graceful degrading of the Solarized color palette on \n    8 color terminals. Infact, the experience should be almost identical to gui \n    other than lack of bold typeface.\n\n*   **VIM : BUGFIX : Better distinction between status bar and split windows**\n    Status bar was previously too similar to the cursor line and window splits.  \n    This has now been changed significantly to improve the clarity of what is \n    status, cursor line and window separator.\n\n*   **VIM : STREAMLINED : Removed simultaneous gui/cterm definitions**\n*   Refactored solarized.vim to eliminate simultaneous definition of gui and \n    cterm values.\n\n*   **VIM : BUGFIX : Removed italicized front in terminal mode**\n    Removed default italicized font in terminal mode in the Solarized Vim\n    colorscheme (many terminal emulators display Vim italics as reversed type).  \n    Italics still used in GUI mode by default and can still be turned off in \n    both modes by setting a variable: `let g:solarized_italic=0`.\n\n1.0.0beta1\n----------\n\nFirst public release. Included:\n\n* Adobe Photoshop Swatches\n* Apple Color Picker Palette\n* Gimp Palette\n* iTerm2 colorschemes\n* Mutt mail client colorschemes\n* OS X Terminal.app colors\n* Vim Colorscheme\n* Xresources colors\n\n\n\n***\n\nMODIFIED: 2011 Apr 16\n&quot;}</code></pre>
<p>As is serialising them.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Blob</span> <span class="kw">where</span>
    toBytes (<span class="dt">Blob</span> content) <span class="fu">=</span> content

(parsed parseBlob <span class="fu">.</span> toBytes <span class="fu">$</span> parsedBlob) <span class="fu">==</span> parsedBlob</code></pre></div>
<pre><code>True</code></pre>
<p>Finally we move to Git tags, which are a way to associate a name with a reference. Git has a handy <code>show-ref --tags</code> command we can use to list them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git show<span class="fu">-</span>ref <span class="co">--tags</span></code></pre></div>
<pre><code>31ff7f5064824d2231648119feb6dfda1a3c89f5 refs/tags/v1.0.0beta1
a3037b428f29f0c032aeeeedb4758501bc32444d refs/tags/v1.0beta</code></pre>
<p>There are two types of tags: lightweight tags and annotated tags. Lightweight tags are just files very much like <code>refs/heads/master</code> containing a ref, and annotated tags have a message associated with them like a commit. Only annotated tags are Git objects.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p 31ff7f5064824d2231648119feb6dfda1a3c89f5</code></pre></div>
<pre><code>object 90581c7bfbcd279768580eec595d0ab3c094cc02
type commit
tag v1.0.0beta1
tagger Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700

Initial public beta release 1.0.0beta1</code></pre>
<p>Although tags are mostly used with commits, it‚Äôs possible to tag any Git object. You can even tag another tag, although I can‚Äôt see why you might want to.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tag <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span>
tag</code></pre></div>
<pre><code>tag 182 object 90581c7bfbcd279768580eec595d0ab3c094cc02
type commit
tag v1.0.0beta1
tagger Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700

Initial public beta release 1.0.0beta1</code></pre>
<p>Our parser for these is very similar to our commit parser. I‚Äôve taken a quick break from my ‚Äòwrite the worst parser possible‚Äô strategy to make sure that our tags can only tag objects of type ‚Äòcommit‚Äô, ‚Äòtree‚Äô, ‚Äòblob‚Äô, or ‚Äòtag‚Äô.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tag</span> <span class="fu">=</span> <span class="dt">Tag</span>
    {<span class="ot"> tagObject     ::</span> <span class="dt">Ref</span>
    ,<span class="ot"> tagType       ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> tagTag        ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> tagTagger     ::</span> <span class="dt">ByteString</span>
    ,<span class="ot"> tagAnnotation ::</span> <span class="dt">ByteString</span>
    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">parseTag ::</span> <span class="dt">Parser</span> <span class="dt">Tag</span>
parseTag <span class="fu">=</span> <span class="kw">do</span>
    tObject     <span class="ot">&lt;-</span> AC.string <span class="st">&quot;object&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                                                 <span class="fu">&lt;*</span> AC.endOfLine
    tType       <span class="ot">&lt;-</span> AC.string <span class="st">&quot;type&quot;</span>   <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.choice (map AC.string [<span class="st">&quot;commit&quot;</span>, <span class="st">&quot;tree&quot;</span>, <span class="st">&quot;blob&quot;</span>, <span class="st">&quot;tag&quot;</span>]) <span class="fu">&lt;*</span> AC.endOfLine
    tTag        <span class="ot">&lt;-</span> AC.string <span class="st">&quot;tag&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>)                               <span class="fu">&lt;*</span> AC.endOfLine
    tTagger     <span class="ot">&lt;-</span> AC.string <span class="st">&quot;tagger&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>)                               <span class="fu">&lt;*</span> AC.endOfLine
    AC.endOfLine
    tAnnotation <span class="ot">&lt;-</span> AC.takeByteString
    return <span class="fu">$</span> <span class="dt">Tag</span> tObject tType tTag tTagger tAnnotation

parsedTag <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseTag) tag
parsedTag</code></pre></div>
<pre><code>Tag {tagObject = &quot;90581c7bfbcd279768580eec595d0ab3c094cc02&quot;, tagType = &quot;commit&quot;, tagTag = &quot;v1.0.0beta1&quot;, tagTagger = &quot;Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700&quot;, tagAnnotation = &quot;Initial public beta release 1.0.0beta1\n&quot;}</code></pre>
<p>Our last serialiser follows.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Tag</span> <span class="kw">where</span>
    toBytes (<span class="dt">Tag</span> tObject tType tTag tTagger tAnnotation) <span class="fu">=</span> mconcat
        [ <span class="st">&quot;object &quot;</span> <span class="fu">&lt;&gt;</span> tObject     <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        , <span class="st">&quot;type &quot;</span>   <span class="fu">&lt;&gt;</span> tType       <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        , <span class="st">&quot;tag &quot;</span>    <span class="fu">&lt;&gt;</span> tTag        <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        , <span class="st">&quot;tagger &quot;</span> <span class="fu">&lt;&gt;</span> tTagger     <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>
        ,                             <span class="st">&quot;\n&quot;</span>
        ,              tAnnotation
        ]

(parsed parseTag <span class="fu">.</span> toBytes <span class="fu">$</span> parsedTag) <span class="fu">==</span> parsedTag</code></pre></div>
<pre><code>True</code></pre>
<p>Okay, now to bring it all together. We can define an umbrella <code>GitObject</code> type and the associated parser, serialiser, and hasher for it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">GitObject</span>
    <span class="fu">=</span> <span class="dt">GitCommit</span> <span class="dt">Commit</span>
    <span class="fu">|</span> <span class="dt">GitTree</span>   <span class="dt">Tree</span>
    <span class="fu">|</span> <span class="dt">GitBlob</span>   <span class="dt">Blob</span>
    <span class="fu">|</span> <span class="dt">GitTag</span>    <span class="dt">Tag</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">parseGitObject ::</span> <span class="dt">Parser</span> <span class="dt">GitObject</span>
parseGitObject <span class="fu">=</span> <span class="kw">do</span>
    headerLen <span class="ot">&lt;-</span> parseHeader
    <span class="kw">case</span> (fst headerLen) <span class="kw">of</span>
        <span class="st">&quot;commit&quot;</span> <span class="ot">-&gt;</span> <span class="dt">GitCommit</span> <span class="fu">&lt;$&gt;</span> parseCommit
        <span class="st">&quot;tree&quot;</span>   <span class="ot">-&gt;</span> <span class="dt">GitTree</span>   <span class="fu">&lt;$&gt;</span> parseTree
        <span class="st">&quot;blob&quot;</span>   <span class="ot">-&gt;</span> <span class="dt">GitBlob</span>   <span class="fu">&lt;$&gt;</span> parseBlob
        <span class="st">&quot;tag&quot;</span>    <span class="ot">-&gt;</span> <span class="dt">GitTag</span>    <span class="fu">&lt;$&gt;</span> parseTag
        _        <span class="ot">-&gt;</span> error <span class="st">&quot;not a git object&quot;</span>

<span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">GitObject</span> <span class="kw">where</span>
    toBytes obj <span class="fu">=</span> <span class="kw">case</span> obj <span class="kw">of</span>
        <span class="dt">GitCommit</span> c <span class="ot">-&gt;</span> withHeader <span class="st">&quot;commit&quot;</span> (toBytes c)
        <span class="dt">GitTree</span>   t <span class="ot">-&gt;</span> withHeader <span class="st">&quot;tree&quot;</span>   (toBytes t)
        <span class="dt">GitBlob</span>   b <span class="ot">-&gt;</span> withHeader <span class="st">&quot;blob&quot;</span>   (toBytes b)
        <span class="dt">GitTag</span>    t <span class="ot">-&gt;</span> withHeader <span class="st">&quot;tag&quot;</span>    (toBytes t)

<span class="ot">hashObject ::</span> <span class="dt">GitObject</span> <span class="ot">-&gt;</span> <span class="dt">Ref</span>
hashObject <span class="fu">=</span> hash <span class="fu">.</span> toBytes</code></pre></div>
<p>Let‚Äôs do a quick test to check that our definitions work.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">hashObject <span class="fu">.</span> parsed parseGitObject <span class="fu">&lt;$&gt;</span> (decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span>)</code></pre></div>
<pre><code>31ff7f5064824d2231648119feb6dfda1a3c89f5</code></pre>
<p>Excellent, although we are lacking a helper to turn a reference into a Git object filepath. Let‚Äôs define that.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.FilePath</span> ((&lt;/&gt;))

<span class="ot">refPath ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Ref</span> <span class="ot">-&gt;</span> FilePath
refPath gitDir ref <span class="fu">=</span> <span class="kw">let</span>
   (dir,file) <span class="fu">=</span> splitAt <span class="dv">2</span> (toString ref)
   <span class="kw">in</span> gitDir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;objects&quot;</span> <span class="fu">&lt;/&gt;</span> dir <span class="fu">&lt;/&gt;</span> file

refPath <span class="st">&quot;.git&quot;</span> <span class="st">&quot;31ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></code></pre></div>
<pre><code>&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</code></pre>
<p>Now we can define a <code>readObject</code> action that takes a reference and returns a parsed Git object.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readObject ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Ref</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GitObject</span>
readObject gitDir ref <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> path <span class="fu">=</span> refPath gitDir ref
    content <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile path
    return <span class="fu">$</span> parsed parseGitObject content

readObject <span class="st">&quot;.git&quot;</span> <span class="st">&quot;31ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></code></pre></div>
<pre><code>GitTag (Tag {tagObject = &quot;90581c7bfbcd279768580eec595d0ab3c094cc02&quot;, tagType = &quot;commit&quot;, tagTag = &quot;v1.0.0beta1&quot;, tagTagger = &quot;Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700&quot;, tagAnnotation = &quot;Initial public beta release 1.0.0beta1\n&quot;})</code></pre>
<p>Next we define a <code>writeObject</code> action that takes a Git object and stores it under the right path if it doesn‚Äôt already exist. The ‚Äúdoesn‚Äôt already exist‚Äù bit is the magic of Git: we can safely assume that an object with the same hash is the same object. Every time a tree or blob changes, only the changed objects are written to the disk, and this is how Git manages to be space-efficient.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Directory</span> (doesPathExist, createDirectoryIfMissing)
<span class="kw">import </span><span class="dt">System.FilePath</span>  (takeDirectory)
<span class="kw">import </span><span class="dt">Control.Monad</span>    (when, unless)

<span class="ot">writeObject ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">GitObject</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Ref</span>
writeObject gitDir object <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> ref  <span class="fu">=</span>  hashObject object
    <span class="kw">let</span> path <span class="fu">=</span>  refPath gitDir ref
    exists   <span class="ot">&lt;-</span> doesPathExist path
    unless exists <span class="fu">$</span> <span class="kw">do</span>
        <span class="kw">let</span> dir <span class="fu">=</span> takeDirectory path
        createDirectoryIfMissing <span class="dt">True</span> dir
        B.writeFile path <span class="fu">.</span> compress <span class="fu">$</span> toBytes object
    return ref</code></pre></div>
<p>Okay, time for the grand finale! We‚Äôre going to read and then write every object in this Git repository. If we‚Äôve implemented everything correctly, the number of references before and after will be unchanged, and they will be the same references.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>    (forM)
<span class="kw">import </span><span class="dt">System.Directory</span> (listDirectory)

allRefs <span class="ot">&lt;-</span> <span class="kw">do</span>
    prefixes <span class="ot">&lt;-</span> filter (\d <span class="ot">-&gt;</span> length d <span class="fu">==</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> listDirectory <span class="st">&quot;.git/objects/&quot;</span>
    concat <span class="fu">&lt;$&gt;</span> forM prefixes (\p <span class="ot">-&gt;</span>
        map (fromString <span class="fu">.</span> (p<span class="fu">++</span>)) <span class="fu">&lt;$&gt;</span> listDirectory (<span class="st">&quot;.git/objects&quot;</span> <span class="fu">&lt;/&gt;</span> p))

print <span class="fu">$</span> length allRefs

test <span class="ot">&lt;-</span> forM allRefs <span class="fu">$</span> \ref <span class="ot">-&gt;</span> <span class="kw">do</span>
    obj  <span class="ot">&lt;-</span> readObject  <span class="st">&quot;.git&quot;</span> ref
    ref' <span class="ot">&lt;-</span> writeObject <span class="st">&quot;.git&quot;</span> obj
    return <span class="fu">$</span> ref <span class="fu">==</span> ref'

and test

allRefs' <span class="ot">&lt;-</span> <span class="kw">do</span>
    prefixes <span class="ot">&lt;-</span> filter (\d <span class="ot">-&gt;</span> length d <span class="fu">==</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> listDirectory <span class="st">&quot;.git/objects/&quot;</span>
    concat <span class="fu">&lt;$&gt;</span> forM prefixes (\p <span class="ot">-&gt;</span>
        map (fromString <span class="fu">.</span> (p<span class="fu">++</span>)) <span class="fu">&lt;$&gt;</span> listDirectory (<span class="st">&quot;.git/objects&quot;</span> <span class="fu">&lt;/&gt;</span> p))

print <span class="fu">$</span> length allRefs'

allRefs <span class="fu">==</span> allRefs'</code></pre></div>
<pre><code>2186



True



2186



True</code></pre>
<p>And that‚Äôs essentially all there is to Git! I‚Äôve skipped over most of the additional quirks, features, and optimisations but I hope I‚Äôve established that even with the relatively small amount of code above you can implement a working and usable Git API.</p>
<p>You‚Äôll notice that one thing I haven‚Äôt mentioned at all is diffing or merging. That‚Äôs because Git doesn‚Äôt store diffs! They are computed on the fly when you ask for them. The packfile format does do diffing as a space optimisation, but I think it‚Äôs important to point out that you can have a perfectly cromulent implementation without them because that is what surprised me the most when I learned this for the first time.</p>
<p>A good mental model of Git empowered me to use it better. I‚Äôd heard that binary files and Git don‚Äôt go well together, but I only understood why recently: Git stores every version of every file, and binary files don‚Äôt compress very well (unlike text files), so they take up huge amounts of space. I‚Äôd also read about <a href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">CocoaPods causing issues for GitHub</a>, and now I know that this is because the tree objects representing the <code>Specs</code> directory were very large and constantly getting updated, leading to a lot of stress on GitHub‚Äôs servers.</p>
<p>What else can you do with this power? You can‚Ä¶</p>
<ul>
<li><a href="https://github.com/vaibhavsagar/git-internals-workshop">Craft your own repositories</a></li>
<li>Run analytics on your commit graph when <code>git log</code> won‚Äôt cut it!</li>
<li><a href="https://github.com/vaibhavsagar/suppandi">Write a web API for your repository!</a></li>
<li><a href="https://github.com/mirage/irmin">Use Git as the backend of your application and get diffing/merging for free!</a></li>
</ul>
<p>The possibilities are endless!</p>
<p>If you‚Äôd like to learn more, you‚Äôre in luck! writing on this topic is plentiful and of extremely high quality. I started with the Git Book‚Äôs <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">chapter on Git Internals</a> and referred frequently to Vincent Hanquez‚Äôs <a href="https://github.com/vincenthz/hs-git/">hs-git</a> and Stefan Saasen‚Äôs <a href="http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/">overwhelmingly thorough article</a> that implements enough of Git to do a <code>git clone</code>(!). Other resources include Mary Rose Cook‚Äôs excellent <a href="https://maryrosecook.com/blog/post/git-from-the-inside-out">Git from the inside out</a> and <a href="http://gitlet.maryrosecook.com/docs/gitlet.html">Gitlet</a> as well as John Wiegley‚Äôs <a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>. If nothing else, I hope the sheer proliferation of Git innards writing is enough to convince you that this is a useful and rewarding approach to learning about it.</p>
<p>Thanks to <a href="https://anniecherkaev.com/">Annie Cherkaev</a>, <a href="https://fineshambles.com/">Iain McCoy</a>, <a href="https://jaseemabid.github.io/">Jaseem Abid</a> and <a href="http://krebsco.de/">Tomislav Viljetic</a> for comments, clarification, and suggestions.</p>

        </div>
        <div id="footer">
            <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
        </div>
    </body>
</html>
